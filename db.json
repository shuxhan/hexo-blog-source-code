{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/BingSiteAuth.xml","path":"BingSiteAuth.xml","modified":0,"renderable":0},{"_id":"themes/simple99/source/css/animate.css","path":"css/animate.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/highlight.css","path":"css/highlight.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/highlight.light.css","path":"css/highlight.light.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/jquery.tocify.css","path":"css/jquery.tocify.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/main.css","path":"css/main.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/nav-icon.css","path":"css/nav-icon.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/nav-indicator.css","path":"css/nav-indicator.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/preloader.css","path":"css/preloader.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/prism-customize.css","path":"css/prism-customize.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/smooth-state-anim.css","path":"css/smooth-state-anim.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/twikoo.css","path":"css/twikoo.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/css/waves.min.css","path":"css/waves.min.css","modified":0,"renderable":1},{"_id":"themes/simple99/source/js/comment.js","path":"js/comment.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/js/copy.js","path":"js/copy.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/lib/jquery-ui.js","path":"lib/jquery-ui.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/lib/jquery.js","path":"lib/jquery.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/lib/jquery.tocify.js","path":"lib/jquery.tocify.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/lib/jquery.tocify.min.js","path":"lib/jquery.tocify.min.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/lib/main.js","path":"lib/main.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/lib/waves.js","path":"lib/waves.js","modified":0,"renderable":1},{"_id":"themes/simple99/source/lib/waves.min.js","path":"lib/waves.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/google5ed86ac455eb8b82.html","hash":"7b4f301160811cf2d5d912f2e95bb22363601279","modified":1609897824000},{"_id":"source/BingSiteAuth.xml","hash":"3ab328f326cc3dfc37cf443ff5a855c65a393bd5","modified":1608347679000},{"_id":"source/.DS_Store","hash":"50c72bc1d57a4a572c90d3dc70f3f1c069f1b822","modified":1611237094000},{"_id":"source/_posts/.DS_Store","hash":"7d1ea67e637189a59da238f56583d212bf95ee65","modified":1611232900000},{"_id":"source/_posts/20200902-static.md","hash":"5a41ee38823e797b4ca9177c8ed2562f137e5d01","modified":1608691330000},{"_id":"source/_posts/20200911-cssworld.md","hash":"c3a5104ef26bef9587a44d2407d13c42d12258d9","modified":1607939956000},{"_id":"source/_posts/20200918-weber.md","hash":"c7e4992e6c0fa7bb3960ae35fa4ce1b8f9367a13","modified":1607939970000},{"_id":"source/_posts/20210114-hexo-typecho.md","hash":"e35b560895cf143970ee2c1c6aafbd3fd5ff645a","modified":1611230440000},{"_id":"source/_posts/20201013-custom.md","hash":"3082a945e54d12fabd998008a6de45ec96071f97","modified":1610517051000},{"_id":"source/_posts/20210107-react-markdown-braft-editor.md","hash":"b261e39a21b1d5e8135f9d26e1a8e232d127f4b8","modified":1610523393000},{"_id":"source/archive/index.md","hash":"d91672c24de275098e39c0d4711c8295f8f76b21","modified":1607330414000},{"_id":"source/about/index.md","hash":"a26f000e19e34d4436972d80eb7033d7e12fc73e","modified":1610763728000},{"_id":"source/_posts/20210106-vue-react-difference.md","hash":"4b934a85078e397380000fb22407223cba3c6b12","modified":1610353164000},{"_id":"source/category/index.md","hash":"02ab60a8c208da15864ea520c25e7f3970ba2f41","modified":1607394027000},{"_id":"source/search/index.md","hash":"6e49325b39f2583d54ae0cf2556336a86b30e569","modified":1608346894000},{"_id":"source/message/index.md","hash":"9b314cf65da7144a011aaeb8391b017d63d745a2","modified":1610363620000},{"_id":"source/tags/index.md","hash":"8795bba8070b869232911f5dc174ec0fc4b3f2ec","modified":1607391163000},{"_id":"themes/simple99/.DS_Store","hash":"66c557232a731eadfa064a0789cb272314629f8d","modified":1610545472000},{"_id":"themes/simple99/LICENSE","hash":"7064d85ea495feef59b6750055201fced70df5d1","modified":1610545472000},{"_id":"themes/simple99/.bowerrc","hash":"5d8502d31f0ed07e935bc6faf5e7f8ce8308ab75","modified":1610545472000},{"_id":"themes/simple99/_config.yml","hash":"636dbd97111525348a88263ebad155183217183a","modified":1611230347000},{"_id":"themes/simple99/package.json","hash":"2d6234da845e8743515c8aad45d3df8834dfe2de","modified":1610545472000},{"_id":"themes/simple99/languages/zh-CN.yml","hash":"ba30a9c463a33bfafdda6044f1f2ba54afd4e91d","modified":1610545472000},{"_id":"themes/simple99/layout/.DS_Store","hash":"4adc06b7c8ff65d9a219a005bd7deeb7f81735c8","modified":1610545472000},{"_id":"themes/simple99/layout/about.ejs","hash":"ae8d35e12f9a093a83f0cece6797de2c7de6ab48","modified":1610545472000},{"_id":"themes/simple99/layout/archive.ejs","hash":"5b0b5ea4d40377a2866822ef0fb18c10a8337584","modified":1610545472000},{"_id":"themes/simple99/layout/category.ejs","hash":"a8eaa292446b1685ffbff57ce2836e72b5e54791","modified":1610545472000},{"_id":"themes/simple99/layout/index.ejs","hash":"e67c20745657b733f5590545076517da3cbd62ba","modified":1610762509000},{"_id":"themes/simple99/README-zh.md","hash":"ccaf080305c2166db7630325394ce8067db4da2a","modified":1610605003000},{"_id":"themes/simple99/layout/layout.ejs","hash":"39450cd577297247de720644826b75cb4aad8eb8","modified":1610545472000},{"_id":"themes/simple99/bower.json","hash":"756d74bd0aa7e112f9e84e84285bacd195f167c4","modified":1610545472000},{"_id":"themes/simple99/README.md","hash":"7c50ccebe6cf363fde276e602ff1fcfffb74bbe0","modified":1610605029000},{"_id":"themes/simple99/layout/page.ejs","hash":"5ebd3010206439bc5482eea1af13cdb80f6b7830","modified":1610545472000},{"_id":"themes/simple99/layout/post.ejs","hash":"d61c476775effbb4104d39cdfeeeda4ab06e4f7b","modified":1610545472000},{"_id":"themes/simple99/layout/search.ejs","hash":"08775c59f4956e0c0e610003f6dacd847fa63c5c","modified":1610545472000},{"_id":"themes/simple99/layout/tag.ejs","hash":"598b83b464d197f78baa57b6374feb313beb06af","modified":1610545472000},{"_id":"themes/simple99/layout/partials/.DS_Store","hash":"655172f06a9aa828111b46b8d8ca62aec6267821","modified":1610545472000},{"_id":"themes/simple99/layout/partials/analytics.ejs","hash":"6ba133799ac450635c99e25f6d2463d1dafc11a7","modified":1610545472000},{"_id":"themes/simple99/layout/message.ejs","hash":"a75935662a9a6b6cb1903e916dddec7c9fe20e98","modified":1611226916000},{"_id":"themes/simple99/layout/partials/article-copy-code.ejs","hash":"0fe6bf593ae4ca8c8c0e5f498050e2c4566285c6","modified":1610545472000},{"_id":"themes/simple99/layout/partials/comments.ejs","hash":"f20e29f1c45052551ee1e86748d53dd3b7102a7d","modified":1611230364000},{"_id":"themes/simple99/layout/partials/footer.ejs","hash":"2fecc42442bc9925b2b62cc0a9ce3c4385436043","modified":1610545472000},{"_id":"themes/simple99/layout/partials/nav.ejs","hash":"73b73a6390f093515107d64c2f43229ec94f454e","modified":1611227629000},{"_id":"themes/simple99/layout/partials/pagination.ejs","hash":"0580020eb197c2cf57e573028967e2bfd8770de7","modified":1610545472000},{"_id":"themes/simple99/layout/partials/theme.ejs","hash":"233e922b31fa33397e42bc8e6e29d21352ebe17d","modified":1610545472000},{"_id":"themes/simple99/layout/partials/title_list.ejs","hash":"ccb3a6e7bd87ed41aa8ca90b9bd00f091887dc6b","modified":1610545472000},{"_id":"themes/simple99/layout/partials/head.ejs","hash":"56bce6051d28d9e9d28385b941be4006e4443a23","modified":1610545472000},{"_id":"themes/simple99/layout/partials/widgets.ejs","hash":"19a491a88a675cbbaeb2cca7967c78e131411cb9","modified":1610545472000},{"_id":"themes/simple99/layout/widget/.DS_Store","hash":"4b2d92ad6226b4b495ffe3e9b7ffa4efd40b02a2","modified":1610545472000},{"_id":"themes/simple99/layout/partials/copyright.ejs","hash":"9942899b19b7d213c4392cad7fca21bb7bc4a0c2","modified":1611146768000},{"_id":"themes/simple99/layout/widget/archive.ejs","hash":"38a6b8e044490077269a0127b82d74b59515aee6","modified":1610545472000},{"_id":"themes/simple99/layout/widget/attention.ejs","hash":"af5fac8ebcdd24c254730a9e2f467d4f7946beb8","modified":1610545472000},{"_id":"themes/simple99/layout/widget/category.ejs","hash":"60ed17e077e54ccd5b0280dc4f7ad5fd2fabdff1","modified":1610545472000},{"_id":"themes/simple99/layout/widget/links.ejs","hash":"62cc2702674bfe824680316f97f819a3478fe53e","modified":1610545472000},{"_id":"themes/simple99/layout/widget/notice.ejs","hash":"811dcfdef09a5b7290f66ab51931565ba5ec3381","modified":1610630937000},{"_id":"themes/simple99/layout/widget/recent_posts.ejs","hash":"d0b3ff666b750eff8f8746e93da9c721e48b405f","modified":1610545472000},{"_id":"themes/simple99/layout/widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1610545472000},{"_id":"themes/simple99/source/css/highlight.light.css","hash":"3b945b847eb30f29828897308cb1efc31199b2d0","modified":1610545472000},{"_id":"themes/simple99/source/css/jquery.tocify.css","hash":"a274d92392cb4fe0f8fb339a5f20b3d82fe495c8","modified":1610545472000},{"_id":"themes/simple99/source/css/main.css","hash":"1a87db9802fdb8552e9f9f0ecd386b8868847cfe","modified":1610591690000},{"_id":"themes/simple99/source/css/nav-icon.css","hash":"a41a9c41848e16c402c5b09683781dcbf61d103d","modified":1610591619000},{"_id":"themes/simple99/source/css/nav-indicator.css","hash":"4648f75060594841bcca07ebeaf99bd719f8e3d6","modified":1610545472000},{"_id":"themes/simple99/source/css/prism-customize.css","hash":"37dedd5ed46d1d337e5fcae071c0ed7b71b85d9a","modified":1610545472000},{"_id":"themes/simple99/source/css/search.css","hash":"b4e0254ca4c8bb10f35e6bd334b307456046c11c","modified":1610545472000},{"_id":"themes/simple99/source/css/highlight.css","hash":"631a7ef33a38cd4f438c7a33df5feaae6b46e4d8","modified":1610545472000},{"_id":"themes/simple99/source/css/twikoo.css","hash":"9da04f551ce05ed71525f89ca385f90164bc8caa","modified":1610545472000},{"_id":"themes/simple99/source/css/waves.min.css","hash":"6cd49978e819697627009a205a85f2ff0e0a009c","modified":1610545472000},{"_id":"themes/simple99/source/js/comment.js","hash":"15175fbb2cdffbdafb40a3106381d715373e4afd","modified":1610545472000},{"_id":"themes/simple99/source/js/copy.js","hash":"89e7a3e73f566b0bce1fb6bd340f8f8a994c48f5","modified":1610545472000},{"_id":"themes/simple99/source/js/main.js","hash":"81fcc1155de54ebe9d9c621e21301b68582a95bb","modified":1610545472000},{"_id":"themes/simple99/source/js/search.js","hash":"3c346defdf66558f84f951d4034210ed07739714","modified":1610545472000},{"_id":"themes/simple99/source/css/preloader.css","hash":"6a64d0102ab21502b0ac11ca635a917f14c7cb73","modified":1610545472000},{"_id":"themes/simple99/source/css/smooth-state-anim.css","hash":"29d6e7f5f4973e1286e9fceea7c145fe6eb2c65f","modified":1610545472000},{"_id":"themes/simple99/source/lib/jquery.tocify.js","hash":"a5b430cde9568b6fcccfc0deb61cd287c1b1017e","modified":1610545472000},{"_id":"themes/simple99/source/lib/waves.js","hash":"3fe0509fbbf82fe340bfe86e7ddb7bda8b1ae309","modified":1610545472000},{"_id":"themes/simple99/source/lib/jquery.tocify.min.js","hash":"b57e1570be4599b7b1e28a21cad309345f081571","modified":1610545472000},{"_id":"themes/simple99/source/lib/main.js","hash":"8e9cdcffeb37893456df2f871d6b31ba8697964e","modified":1610545472000},{"_id":"themes/simple99/source/lib/waves.min.js","hash":"9b955c7464e32ef9c641537b2e9bc3e50506a3a7","modified":1610545472000},{"_id":"themes/simple99/source/css/animate.css","hash":"706475f47013d79b7e7cbe84e3cda2b52b18875d","modified":1610545472000},{"_id":"themes/simple99/source/lib/jquery.js","hash":"3b0f35285a7088b1fd321773696f9d3b45d31942","modified":1610545472000},{"_id":"themes/simple99/source/lib/jquery-ui.js","hash":"8689f0993aa736965899d1e3bbe40c3378416191","modified":1610545472000},{"_id":"public/atom.xml","hash":"af95f0940ce996087a9dabbdc2dcb303ee340421","modified":1611230455468},{"_id":"public/search.xml","hash":"174ba37ae9295deaa6a67b96c87f340625b8baec","modified":1611230455468},{"_id":"public/archive/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1611230455468},{"_id":"public/category/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1611230455468},{"_id":"public/google5ed86ac455eb8b82.html","hash":"1f7830b7bc93aaac41c021f6804686a496a41054","modified":1611230455468},{"_id":"public/about/index.html","hash":"0e665d9a898e63b6446ea04987b76ef8df3c5b15","modified":1611230455468},{"_id":"public/message/index.html","hash":"d540210b6e7eacc9af14b74aa9ede25cef35428b","modified":1611230455468},{"_id":"public/search/index.html","hash":"8d7ad91de19457d0e4b3bbb9b80258d3754c7530","modified":1611230455468},{"_id":"public/tags/index.html","hash":"a4c1286ef882d7774db2e2abad3efccc47609bba","modified":1611230455468},{"_id":"public/2021/01/14/20210114-hexo-typecho/index.html","hash":"879b11710f7122972dac87551054e43e115f4012","modified":1611230455468},{"_id":"public/2021/01/07/20210107-react-markdown-braft-editor/index.html","hash":"52e14b2fcaf6ecf1a358baaee7f3f1017f63c42e","modified":1611230455468},{"_id":"public/2021/01/06/20210106-vue-react-difference/index.html","hash":"cf97f267a137239a656fd590a4f48ef1b8041c71","modified":1611230455468},{"_id":"public/2020/10/13/20201013-custom/index.html","hash":"2bfdec2868b6e7ef1d4c56df5c98b6b611efea71","modified":1611230455468},{"_id":"public/2020/09/18/20200918-weber/index.html","hash":"0348c2216cb722dc778af455c8d784723357770b","modified":1611230455468},{"_id":"public/2020/09/11/20200911-cssworld/index.html","hash":"a9c4eb60b753c11e8d7cd8c4c6ca007a33bd6f39","modified":1611230455468},{"_id":"public/2020/09/02/20200902-static/index.html","hash":"820d3267a9e83319533fd5627606e75fc56b5309","modified":1611230455468},{"_id":"public/archives/index.html","hash":"6f4fb3dbb708eeb595805ed3a9c652ae7dfca5d2","modified":1611230455468},{"_id":"public/archives/2020/index.html","hash":"968aec3b4b01142b0efbbbf46509f0452dc6c4ba","modified":1611230455468},{"_id":"public/archives/2020/09/index.html","hash":"f09137dd984b805d8e0932be45632c41b997af25","modified":1611230455468},{"_id":"public/archives/2020/10/index.html","hash":"72b3fc97f527794e2408ce401010d7915f267922","modified":1611230455468},{"_id":"public/archives/2021/index.html","hash":"4e767f32a02bcf6ad0cfb111eb974b0226fb6fe9","modified":1611230455468},{"_id":"public/archives/2021/01/index.html","hash":"3f511f9b06108e8d3884b97045b100c1c181580f","modified":1611230455468},{"_id":"public/categories/其他/index.html","hash":"f2ee17ea885ffa1054e33991d2eb888056844e16","modified":1611230455468},{"_id":"public/categories/随笔文章/index.html","hash":"22244eca59ca881883f1eae9357fc8c51d4af9c6","modified":1611230455468},{"_id":"public/categories/前端技术/index.html","hash":"2a7fe429ef0e94aff73555511a23d7a99045ad2f","modified":1611230455468},{"_id":"public/index.html","hash":"4d224d764808c0bff228b221a6bcf1aa59af88cc","modified":1611230455468},{"_id":"public/tags/建站手册及问题/index.html","hash":"eaf7b32ff9c745f29097a3dadd933c8a648f5f34","modified":1611230455468},{"_id":"public/tags/react-杂谈/index.html","hash":"d166c13de445f0a46e060b352039de7fd6e3c45b","modified":1611230455468},{"_id":"public/tags/组件库/index.html","hash":"7a1c95072086bb356c26cc804cadbc6ffdca9e55","modified":1611230455468},{"_id":"public/BingSiteAuth.xml","hash":"3ab328f326cc3dfc37cf443ff5a855c65a393bd5","modified":1611230455468},{"_id":"public/css/highlight.css","hash":"631a7ef33a38cd4f438c7a33df5feaae6b46e4d8","modified":1611230455468},{"_id":"public/css/highlight.light.css","hash":"3b945b847eb30f29828897308cb1efc31199b2d0","modified":1611230455468},{"_id":"public/css/jquery.tocify.css","hash":"a274d92392cb4fe0f8fb339a5f20b3d82fe495c8","modified":1611230455468},{"_id":"public/css/nav-icon.css","hash":"a41a9c41848e16c402c5b09683781dcbf61d103d","modified":1611230455468},{"_id":"public/css/nav-indicator.css","hash":"4648f75060594841bcca07ebeaf99bd719f8e3d6","modified":1611230455468},{"_id":"public/css/preloader.css","hash":"6a64d0102ab21502b0ac11ca635a917f14c7cb73","modified":1611230455468},{"_id":"public/css/prism-customize.css","hash":"37dedd5ed46d1d337e5fcae071c0ed7b71b85d9a","modified":1611230455468},{"_id":"public/css/search.css","hash":"b4e0254ca4c8bb10f35e6bd334b307456046c11c","modified":1611230455468},{"_id":"public/css/smooth-state-anim.css","hash":"29d6e7f5f4973e1286e9fceea7c145fe6eb2c65f","modified":1611230455468},{"_id":"public/css/twikoo.css","hash":"9da04f551ce05ed71525f89ca385f90164bc8caa","modified":1611230455468},{"_id":"public/css/waves.min.css","hash":"6cd49978e819697627009a205a85f2ff0e0a009c","modified":1611230455468},{"_id":"public/js/comment.js","hash":"15175fbb2cdffbdafb40a3106381d715373e4afd","modified":1611230455468},{"_id":"public/js/copy.js","hash":"89e7a3e73f566b0bce1fb6bd340f8f8a994c48f5","modified":1611230455468},{"_id":"public/js/main.js","hash":"81fcc1155de54ebe9d9c621e21301b68582a95bb","modified":1611230455468},{"_id":"public/js/search.js","hash":"3c346defdf66558f84f951d4034210ed07739714","modified":1611230455468},{"_id":"public/lib/jquery.tocify.min.js","hash":"b57e1570be4599b7b1e28a21cad309345f081571","modified":1611230455468},{"_id":"public/lib/main.js","hash":"8e9cdcffeb37893456df2f871d6b31ba8697964e","modified":1611230455468},{"_id":"public/lib/waves.min.js","hash":"9b955c7464e32ef9c641537b2e9bc3e50506a3a7","modified":1611230455468},{"_id":"public/css/main.css","hash":"1a87db9802fdb8552e9f9f0ecd386b8868847cfe","modified":1611230455468},{"_id":"public/lib/waves.js","hash":"3fe0509fbbf82fe340bfe86e7ddb7bda8b1ae309","modified":1611230455468},{"_id":"public/lib/jquery.tocify.js","hash":"a5b430cde9568b6fcccfc0deb61cd287c1b1017e","modified":1611230455468},{"_id":"public/css/animate.css","hash":"706475f47013d79b7e7cbe84e3cda2b52b18875d","modified":1611230455468},{"_id":"public/lib/jquery.js","hash":"3b0f35285a7088b1fd321773696f9d3b45d31942","modified":1611230455468},{"_id":"public/lib/jquery-ui.js","hash":"8689f0993aa736965899d1e3bbe40c3378416191","modified":1611230455468}],"Category":[{"name":"其他","_id":"ckk6t0gye0004s6f0g0lccj5u"},{"name":"随笔文章","_id":"ckk6t0gym000cs6f06acqh55n"},{"name":"前端技术","_id":"ckk6t0gyx000ns6f04hk68mdi"}],"Data":[],"Page":[{"_content":"google-site-verification: google5ed86ac455eb8b82.html","source":"google5ed86ac455eb8b82.html","raw":"google-site-verification: google5ed86ac455eb8b82.html","date":"2021-01-06T01:50:42.000Z","updated":"2021-01-06T01:50:24.000Z","path":"google5ed86ac455eb8b82.html","title":"","comments":1,"layout":"page","_id":"ckk6t0gy40000s6f0bwpo358s","content":"google-site-verification: google5ed86ac455eb8b82.html","site":{"data":{}},"length":52,"excerpt":"","more":"google-site-verification: google5ed86ac455eb8b82.html"},{"title":"关于我","layout":"about","_content":"\n经常逛各种技术论坛，博客网站等，发现很多人喜欢记录自己，分享工作中遇到的问题和技术点，这是我萌生写博客的起点。\n \n\n---\n\n1. 2020年10月, 进入新的工作环境</p>\n2. 2020年6月, 大学毕业踏上人生新征程</p>\n\n---\n\n## 联系方式\n\ne-mail：zsh981109@163.com\n \n## 相关\n\n>github主页：[https://github.com/shuxhan](https://github.com/shuxhan)\n>主题仓库：[https://github.com/shuxhan/hexo-theme-simple99](https://github.com/shuxhan/hexo-theme-simple99)\n\n<br>","source":"about/index.md","raw":"---\ntitle: 关于我\nlayout: about\n---\n\n经常逛各种技术论坛，博客网站等，发现很多人喜欢记录自己，分享工作中遇到的问题和技术点，这是我萌生写博客的起点。\n \n\n---\n\n1. 2020年10月, 进入新的工作环境</p>\n2. 2020年6月, 大学毕业踏上人生新征程</p>\n\n---\n\n## 联系方式\n\ne-mail：zsh981109@163.com\n \n## 相关\n\n>github主页：[https://github.com/shuxhan](https://github.com/shuxhan)\n>主题仓库：[https://github.com/shuxhan/hexo-theme-simple99](https://github.com/shuxhan/hexo-theme-simple99)\n\n<br>","date":"2021-01-16T02:22:08.000Z","updated":"2021-01-16T02:22:08.000Z","path":"about/index.html","comments":1,"_id":"ckk6t0gyb0002s6f03dijfqys","content":"<p>经常逛各种技术论坛，博客网站等，发现很多人喜欢记录自己，分享工作中遇到的问题和技术点，这是我萌生写博客的起点。</p>\n<hr>\n<ol>\n<li>2020年10月, 进入新的工作环境</p></li>\n<li>2020年6月, 大学毕业踏上人生新征程</p></li>\n</ol>\n<hr>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><p>e-mail：<a href=\"mailto:&#122;&#x73;&#104;&#x39;&#56;&#x31;&#x31;&#48;&#57;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;\">&#122;&#x73;&#104;&#x39;&#56;&#x31;&#x31;&#48;&#57;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;</a></p>\n<h2 id=\"相关\"><a href=\"#相关\" class=\"headerlink\" title=\"相关\"></a>相关</h2><blockquote>\n<p>github主页：<a href=\"https://github.com/shuxhan\">https://github.com/shuxhan</a><br>主题仓库：<a href=\"https://github.com/shuxhan/hexo-theme-simple99\">https://github.com/shuxhan/hexo-theme-simple99</a></p>\n</blockquote>\n<br>","site":{"data":{}},"length":288,"excerpt":"","more":"<p>经常逛各种技术论坛，博客网站等，发现很多人喜欢记录自己，分享工作中遇到的问题和技术点，这是我萌生写博客的起点。</p>\n<hr>\n<ol>\n<li>2020年10月, 进入新的工作环境</p></li>\n<li>2020年6月, 大学毕业踏上人生新征程</p></li>\n</ol>\n<hr>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><p>e-mail：<a href=\"mailto:&#122;&#x73;&#104;&#x39;&#56;&#x31;&#x31;&#48;&#57;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;\">&#122;&#x73;&#104;&#x39;&#56;&#x31;&#x31;&#48;&#57;&#x40;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;</a></p>\n<h2 id=\"相关\"><a href=\"#相关\" class=\"headerlink\" title=\"相关\"></a>相关</h2><blockquote>\n<p>github主页：<a href=\"https://github.com/shuxhan\">https://github.com/shuxhan</a><br>主题仓库：<a href=\"https://github.com/shuxhan/hexo-theme-simple99\">https://github.com/shuxhan/hexo-theme-simple99</a></p>\n</blockquote>\n<br>"},{"title":"归档","layout":"archive","_content":"","source":"archive/index.md","raw":"---\ntitle: 归档\nlayout: archive\n---","date":"2020-12-30T07:53:30.000Z","updated":"2020-12-07T08:40:14.000Z","path":"archive/index.html","comments":1,"_id":"ckk6t0gyg0006s6f06fsj7c19","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"分类","layout":"category","_content":"","source":"category/index.md","raw":"---\ntitle: 分类 \nlayout: category\n---","date":"2020-12-30T07:53:30.000Z","updated":"2020-12-08T02:20:27.000Z","path":"category/index.html","comments":1,"_id":"ckk6t0gyj0008s6f06y8c7vnu","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"留言","layout":"message","_content":"\n>世界上最遥远的距离就是，我在这里，你却不留下一点点信息。","source":"message/index.md","raw":"---\ntitle: 留言\nlayout: message\n---\n\n>世界上最遥远的距离就是，我在这里，你却不留下一点点信息。","date":"2021-01-11T11:13:40.000Z","updated":"2021-01-11T11:13:40.000Z","path":"message/index.html","comments":1,"_id":"ckk6t0gyl000as6f03x192354","content":"<blockquote>\n<p>世界上最遥远的距离就是，我在这里，你却不留下一点点信息。</p>\n</blockquote>\n","site":{"data":{}},"length":28,"excerpt":"","more":"<blockquote>\n<p>世界上最遥远的距离就是，我在这里，你却不留下一点点信息。</p>\n</blockquote>\n"},{"title":"搜索","layout":"search","_content":"","source":"search/index.md","raw":"---\ntitle: 搜索\nlayout: search\n---\n","date":"2020-12-30T07:53:30.000Z","updated":"2020-12-19T03:01:34.000Z","path":"search/index.html","comments":1,"_id":"ckk6t0gyn000es6f06qg4fs8j","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"tag","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tag\nlayout: tags\n---","date":"2020-12-30T07:53:30.000Z","updated":"2020-12-08T01:32:43.000Z","path":"tags/index.html","comments":1,"_id":"ckk6t0gyr000hs6f0c49vcuqf","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"基于github pages搭建静态网站","date":"2020-09-01T16:00:00.000Z","toc":true,"_content":"\n本篇主要讲一个基于github pages搭建的静态网站的全过程，和我在写代码的过程中遇到的问题详解，记录一下自己学习的过程。\n<!-- more -->\n\n\n>推荐阅读:自定义域名的方法：[github pages怎么自定义域名？](../20201013-custom)\n\n我在平时学习的时候有一个喜欢记录的过程，然后就是写博客，之前在csdn、掘金等地方写，在观摩大牛的时候，我发现他们都喜欢自己做一个博客网站，然后在里面写东西，我就想我能不能也自己搭一个网站。\n\n经过翻阅，我发现这个过程其实也不难，但是有一些细节需要注意，然后再加上一些简单的前端技术，基本就能完成，并且可以基于github pages搭建，相当于一个免费的服务器，对个人来说很实用。\n\n## 1 第一步：先建一个仓库\n\n注册账号什么的我就不提了，和我们平时注册别的软件的过程一样，直接说创建仓库\n\n在github创建一个和用户名一样的，且后缀为github.io 的仓库名，比如我的用户名是shuxhan,所以我的仓库名就是`shuxhan.github.io`，其他的默认勾选就行，直接确认建立\n\n## 2 第二步：在本地写好网页代码\n\n（因为找不到喜欢的模板，所以我就自己构思了一个简陋的网站模型，以后再慢慢修补吧）\n\n在本地新建一个文件夹我们命令为blog,然后在blog里面新建一个index.html的文件，如图：\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6dbcdb28-ea2d-4770-bdf2-c64cb1c21145.png)\n\n在里面随便写点东西\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/0dbaabe9-be43-4dce-9ef6-23475ff7f054.png)\n\n接下来我们就要上传这个文件到github上面\n\n## 3 第三步：上传文件到git\n\n直接百度 git ，然后下载软件\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/ce80c2da-332e-46b5-9710-2cd73a0e8e2d.png)\n\n下载完之后，点击鼠标右键就会发现有Git Bash Here的按钮\n\n这时候，打开blog文件夹，右键点击Git Bash Here，会弹出一个命令提示框\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/9d9eb5d1-085c-40d8-9c7d-b9f902c8782f.png)\n\n接下来是最关键的，我们要输入一系列指令\n\n先前我们在注册github时用的用户名和邮箱，我就以自己为例：\n````shell shell\ngit config --global user.name 'shuxhan'                \n# 用户名\ngit config --global user.email 'xxxxxxx@163.com'       \n# 邮箱\n````\n\n**注意，引号里面填的是自己信息**\n\n然后我们要初始化仓库，输入：\n\n````shell shell\ngit init\n# 在dist中会自动生成一个名为  .git  的文件，不用管\n````\n然后上传到本地库，也就是那个 .git 文件，先输入：\n````shell shell\ngit add .\n````\n\n然后输入注释，这个最关键，不能遗漏，中文英文都可以，以后查看的时候就知道这一次提交的是什么代码，方便查找，输入：\n````shell shell\ngit commit -m \"这是第一次更新demo\"\n# 双引号里面必须写注释，不能省略，否则会报错\n````\n\n接下来就本地库与远程仓库链接起来，打开你最开始建立的仓库，点击code，你会发现一个仓库地址，直接复制这个地址，然后输入指令，<font color=\"red\">在指令后面粘贴刚才复制的地址</font>\n\n````shell shell\ngit remote add origin + 地址\n````\n\n最后将文件上传到云端，也就是最开始在github创建的仓库，直接输入指令\n````shell shell\ngit push -u origin master\n````\n\nOK，完成，这时候你打开github的时候就会发现需要上传到的文件已经在库里了。\n\n进入setting界面，往下滑可以看到github pages\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/a68823f5-0135-4010-9abb-11adb0473b0c.png)\n\n接下来就是打开网站，shuxhan.github.io，我们直接在网址中输入它，然后打开，因为网速问题可能就会几分钟才能刷新出来，来看看成功之后的界面吧\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6e14340a-1761-48ce-b283-7b19c98fd164.png)\n\nOK，网站成功建立，接下来就可以自己随意的往里面添加内容啦！\n\n## 4 第四步：更新仓库\n\n每次写完一篇博客我们要更新到网站上，这里推送在Git的步骤和之前不太一样\n\n在桌面右键点击git bash here，输入\n\n````shell shell\ngit clone +仓库地址\n````\n\n将桌面生成的文件夹里面除了.git之外的所有内容删除，差不多就是清空了，因为.git是上传用的文件夹所以留着\n\n然后将本地的代码文件和文件夹全部粘贴到clone下来的文件夹里\n\n在该文件夹中右键git bash here,同步仓库信息，输入：\n\n````shell shell\ngit pull origin master\n````\n\n接下来就是上传代码到本地仓库\n\n````shell shell\ngit add .\n# 上传文件\n \ngit commit -m \"\"\n# 添加备注\n````\n\npush到云端仓库\n\n````shell shell\ngit push origin master\n````\n\n网站很容易就可以建设，最重要的是其中的内容，希望自己可以坚持一直记录博客，不能半途而废！\n\n书山有路勤为径，学海无涯苦作舟！\n\n","source":"_posts/20200902-static.md","raw":"---\ntitle: 基于github pages搭建静态网站\ndate: 2020-09-02\ntags: 建站手册及问题\ncategories: 其他\ntoc: true\n---\n\n本篇主要讲一个基于github pages搭建的静态网站的全过程，和我在写代码的过程中遇到的问题详解，记录一下自己学习的过程。\n<!-- more -->\n\n\n>推荐阅读:自定义域名的方法：[github pages怎么自定义域名？](../20201013-custom)\n\n我在平时学习的时候有一个喜欢记录的过程，然后就是写博客，之前在csdn、掘金等地方写，在观摩大牛的时候，我发现他们都喜欢自己做一个博客网站，然后在里面写东西，我就想我能不能也自己搭一个网站。\n\n经过翻阅，我发现这个过程其实也不难，但是有一些细节需要注意，然后再加上一些简单的前端技术，基本就能完成，并且可以基于github pages搭建，相当于一个免费的服务器，对个人来说很实用。\n\n## 1 第一步：先建一个仓库\n\n注册账号什么的我就不提了，和我们平时注册别的软件的过程一样，直接说创建仓库\n\n在github创建一个和用户名一样的，且后缀为github.io 的仓库名，比如我的用户名是shuxhan,所以我的仓库名就是`shuxhan.github.io`，其他的默认勾选就行，直接确认建立\n\n## 2 第二步：在本地写好网页代码\n\n（因为找不到喜欢的模板，所以我就自己构思了一个简陋的网站模型，以后再慢慢修补吧）\n\n在本地新建一个文件夹我们命令为blog,然后在blog里面新建一个index.html的文件，如图：\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6dbcdb28-ea2d-4770-bdf2-c64cb1c21145.png)\n\n在里面随便写点东西\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/0dbaabe9-be43-4dce-9ef6-23475ff7f054.png)\n\n接下来我们就要上传这个文件到github上面\n\n## 3 第三步：上传文件到git\n\n直接百度 git ，然后下载软件\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/ce80c2da-332e-46b5-9710-2cd73a0e8e2d.png)\n\n下载完之后，点击鼠标右键就会发现有Git Bash Here的按钮\n\n这时候，打开blog文件夹，右键点击Git Bash Here，会弹出一个命令提示框\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/9d9eb5d1-085c-40d8-9c7d-b9f902c8782f.png)\n\n接下来是最关键的，我们要输入一系列指令\n\n先前我们在注册github时用的用户名和邮箱，我就以自己为例：\n````shell shell\ngit config --global user.name 'shuxhan'                \n# 用户名\ngit config --global user.email 'xxxxxxx@163.com'       \n# 邮箱\n````\n\n**注意，引号里面填的是自己信息**\n\n然后我们要初始化仓库，输入：\n\n````shell shell\ngit init\n# 在dist中会自动生成一个名为  .git  的文件，不用管\n````\n然后上传到本地库，也就是那个 .git 文件，先输入：\n````shell shell\ngit add .\n````\n\n然后输入注释，这个最关键，不能遗漏，中文英文都可以，以后查看的时候就知道这一次提交的是什么代码，方便查找，输入：\n````shell shell\ngit commit -m \"这是第一次更新demo\"\n# 双引号里面必须写注释，不能省略，否则会报错\n````\n\n接下来就本地库与远程仓库链接起来，打开你最开始建立的仓库，点击code，你会发现一个仓库地址，直接复制这个地址，然后输入指令，<font color=\"red\">在指令后面粘贴刚才复制的地址</font>\n\n````shell shell\ngit remote add origin + 地址\n````\n\n最后将文件上传到云端，也就是最开始在github创建的仓库，直接输入指令\n````shell shell\ngit push -u origin master\n````\n\nOK，完成，这时候你打开github的时候就会发现需要上传到的文件已经在库里了。\n\n进入setting界面，往下滑可以看到github pages\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/a68823f5-0135-4010-9abb-11adb0473b0c.png)\n\n接下来就是打开网站，shuxhan.github.io，我们直接在网址中输入它，然后打开，因为网速问题可能就会几分钟才能刷新出来，来看看成功之后的界面吧\n\n![](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6e14340a-1761-48ce-b283-7b19c98fd164.png)\n\nOK，网站成功建立，接下来就可以自己随意的往里面添加内容啦！\n\n## 4 第四步：更新仓库\n\n每次写完一篇博客我们要更新到网站上，这里推送在Git的步骤和之前不太一样\n\n在桌面右键点击git bash here，输入\n\n````shell shell\ngit clone +仓库地址\n````\n\n将桌面生成的文件夹里面除了.git之外的所有内容删除，差不多就是清空了，因为.git是上传用的文件夹所以留着\n\n然后将本地的代码文件和文件夹全部粘贴到clone下来的文件夹里\n\n在该文件夹中右键git bash here,同步仓库信息，输入：\n\n````shell shell\ngit pull origin master\n````\n\n接下来就是上传代码到本地仓库\n\n````shell shell\ngit add .\n# 上传文件\n \ngit commit -m \"\"\n# 添加备注\n````\n\npush到云端仓库\n\n````shell shell\ngit push origin master\n````\n\n网站很容易就可以建设，最重要的是其中的内容，希望自己可以坚持一直记录博客，不能半途而废！\n\n书山有路勤为径，学海无涯苦作舟！\n\n","slug":"20200902-static","published":1,"updated":"2020-12-23T02:42:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6t0gy80001s6f0huuyb7rl","content":"<p>本篇主要讲一个基于github pages搭建的静态网站的全过程，和我在写代码的过程中遇到的问题详解，记录一下自己学习的过程。</p>\n<a id=\"more\"></a>\n\n\n<blockquote>\n<p>推荐阅读:自定义域名的方法：<a href=\"../20201013-custom\">github pages怎么自定义域名？</a></p>\n</blockquote>\n<p>我在平时学习的时候有一个喜欢记录的过程，然后就是写博客，之前在csdn、掘金等地方写，在观摩大牛的时候，我发现他们都喜欢自己做一个博客网站，然后在里面写东西，我就想我能不能也自己搭一个网站。</p>\n<p>经过翻阅，我发现这个过程其实也不难，但是有一些细节需要注意，然后再加上一些简单的前端技术，基本就能完成，并且可以基于github pages搭建，相当于一个免费的服务器，对个人来说很实用。</p>\n<h2 id=\"1-第一步：先建一个仓库\"><a href=\"#1-第一步：先建一个仓库\" class=\"headerlink\" title=\"1 第一步：先建一个仓库\"></a>1 第一步：先建一个仓库</h2><p>注册账号什么的我就不提了，和我们平时注册别的软件的过程一样，直接说创建仓库</p>\n<p>在github创建一个和用户名一样的，且后缀为github.io 的仓库名，比如我的用户名是shuxhan,所以我的仓库名就是<code>shuxhan.github.io</code>，其他的默认勾选就行，直接确认建立</p>\n<h2 id=\"2-第二步：在本地写好网页代码\"><a href=\"#2-第二步：在本地写好网页代码\" class=\"headerlink\" title=\"2 第二步：在本地写好网页代码\"></a>2 第二步：在本地写好网页代码</h2><p>（因为找不到喜欢的模板，所以我就自己构思了一个简陋的网站模型，以后再慢慢修补吧）</p>\n<p>在本地新建一个文件夹我们命令为blog,然后在blog里面新建一个index.html的文件，如图：</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6dbcdb28-ea2d-4770-bdf2-c64cb1c21145.png\"></p>\n<p>在里面随便写点东西</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/0dbaabe9-be43-4dce-9ef6-23475ff7f054.png\"></p>\n<p>接下来我们就要上传这个文件到github上面</p>\n<h2 id=\"3-第三步：上传文件到git\"><a href=\"#3-第三步：上传文件到git\" class=\"headerlink\" title=\"3 第三步：上传文件到git\"></a>3 第三步：上传文件到git</h2><p>直接百度 git ，然后下载软件</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/ce80c2da-332e-46b5-9710-2cd73a0e8e2d.png\"></p>\n<p>下载完之后，点击鼠标右键就会发现有Git Bash Here的按钮</p>\n<p>这时候，打开blog文件夹，右键点击Git Bash Here，会弹出一个命令提示框</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/9d9eb5d1-085c-40d8-9c7d-b9f902c8782f.png\"></p>\n<p>接下来是最关键的，我们要输入一系列指令</p>\n<p>先前我们在注册github时用的用户名和邮箱，我就以自己为例：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &#x27;shuxhan&#x27;                </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 用户名</span></span><br><span class=\"line\">git config --global user.email &#x27;xxxxxxx@163.com&#x27;       </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 邮箱</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意，引号里面填的是自己信息</strong></p>\n<p>然后我们要初始化仓库，输入：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在dist中会自动生成一个名为  .git  的文件，不用管</span></span><br></pre></td></tr></table></figure>\n<p>然后上传到本地库，也就是那个 .git 文件，先输入：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n<p>然后输入注释，这个最关键，不能遗漏，中文英文都可以，以后查看的时候就知道这一次提交的是什么代码，方便查找，输入：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;这是第一次更新demo&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 双引号里面必须写注释，不能省略，否则会报错</span></span><br></pre></td></tr></table></figure>\n<p>接下来就本地库与远程仓库链接起来，打开你最开始建立的仓库，点击code，你会发现一个仓库地址，直接复制这个地址，然后输入指令，<font color=\"red\">在指令后面粘贴刚才复制的地址</font></p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin + 地址</span><br></pre></td></tr></table></figure>\n<p>最后将文件上传到云端，也就是最开始在github创建的仓库，直接输入指令</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>OK，完成，这时候你打开github的时候就会发现需要上传到的文件已经在库里了。</p>\n<p>进入setting界面，往下滑可以看到github pages</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/a68823f5-0135-4010-9abb-11adb0473b0c.png\"></p>\n<p>接下来就是打开网站，shuxhan.github.io，我们直接在网址中输入它，然后打开，因为网速问题可能就会几分钟才能刷新出来，来看看成功之后的界面吧</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6e14340a-1761-48ce-b283-7b19c98fd164.png\"></p>\n<p>OK，网站成功建立，接下来就可以自己随意的往里面添加内容啦！</p>\n<h2 id=\"4-第四步：更新仓库\"><a href=\"#4-第四步：更新仓库\" class=\"headerlink\" title=\"4 第四步：更新仓库\"></a>4 第四步：更新仓库</h2><p>每次写完一篇博客我们要更新到网站上，这里推送在Git的步骤和之前不太一样</p>\n<p>在桌面右键点击git bash here，输入</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone +仓库地址</span><br></pre></td></tr></table></figure>\n<p>将桌面生成的文件夹里面除了.git之外的所有内容删除，差不多就是清空了，因为.git是上传用的文件夹所以留着</p>\n<p>然后将本地的代码文件和文件夹全部粘贴到clone下来的文件夹里</p>\n<p>在该文件夹中右键git bash here,同步仓库信息，输入：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<p>接下来就是上传代码到本地仓库</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 上传文件</span></span><br><span class=\"line\"> </span><br><span class=\"line\">git commit -m &quot;&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加备注</span></span><br></pre></td></tr></table></figure>\n<p>push到云端仓库</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<p>网站很容易就可以建设，最重要的是其中的内容，希望自己可以坚持一直记录博客，不能半途而废！</p>\n<p>书山有路勤为径，学海无涯苦作舟！</p>\n","site":{"data":{}},"length":1777,"excerpt":"<p>本篇主要讲一个基于github pages搭建的静态网站的全过程，和我在写代码的过程中遇到的问题详解，记录一下自己学习的过程。</p>","more":"<blockquote>\n<p>推荐阅读:自定义域名的方法：<a href=\"../20201013-custom\">github pages怎么自定义域名？</a></p>\n</blockquote>\n<p>我在平时学习的时候有一个喜欢记录的过程，然后就是写博客，之前在csdn、掘金等地方写，在观摩大牛的时候，我发现他们都喜欢自己做一个博客网站，然后在里面写东西，我就想我能不能也自己搭一个网站。</p>\n<p>经过翻阅，我发现这个过程其实也不难，但是有一些细节需要注意，然后再加上一些简单的前端技术，基本就能完成，并且可以基于github pages搭建，相当于一个免费的服务器，对个人来说很实用。</p>\n<h2 id=\"1-第一步：先建一个仓库\"><a href=\"#1-第一步：先建一个仓库\" class=\"headerlink\" title=\"1 第一步：先建一个仓库\"></a>1 第一步：先建一个仓库</h2><p>注册账号什么的我就不提了，和我们平时注册别的软件的过程一样，直接说创建仓库</p>\n<p>在github创建一个和用户名一样的，且后缀为github.io 的仓库名，比如我的用户名是shuxhan,所以我的仓库名就是<code>shuxhan.github.io</code>，其他的默认勾选就行，直接确认建立</p>\n<h2 id=\"2-第二步：在本地写好网页代码\"><a href=\"#2-第二步：在本地写好网页代码\" class=\"headerlink\" title=\"2 第二步：在本地写好网页代码\"></a>2 第二步：在本地写好网页代码</h2><p>（因为找不到喜欢的模板，所以我就自己构思了一个简陋的网站模型，以后再慢慢修补吧）</p>\n<p>在本地新建一个文件夹我们命令为blog,然后在blog里面新建一个index.html的文件，如图：</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6dbcdb28-ea2d-4770-bdf2-c64cb1c21145.png\"></p>\n<p>在里面随便写点东西</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/0dbaabe9-be43-4dce-9ef6-23475ff7f054.png\"></p>\n<p>接下来我们就要上传这个文件到github上面</p>\n<h2 id=\"3-第三步：上传文件到git\"><a href=\"#3-第三步：上传文件到git\" class=\"headerlink\" title=\"3 第三步：上传文件到git\"></a>3 第三步：上传文件到git</h2><p>直接百度 git ，然后下载软件</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/ce80c2da-332e-46b5-9710-2cd73a0e8e2d.png\"></p>\n<p>下载完之后，点击鼠标右键就会发现有Git Bash Here的按钮</p>\n<p>这时候，打开blog文件夹，右键点击Git Bash Here，会弹出一个命令提示框</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/9d9eb5d1-085c-40d8-9c7d-b9f902c8782f.png\"></p>\n<p>接下来是最关键的，我们要输入一系列指令</p>\n<p>先前我们在注册github时用的用户名和邮箱，我就以自己为例：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &#x27;shuxhan&#x27;                </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 用户名</span></span><br><span class=\"line\">git config --global user.email &#x27;xxxxxxx@163.com&#x27;       </span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 邮箱</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意，引号里面填的是自己信息</strong></p>\n<p>然后我们要初始化仓库，输入：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在dist中会自动生成一个名为  .git  的文件，不用管</span></span><br></pre></td></tr></table></figure>\n<p>然后上传到本地库，也就是那个 .git 文件，先输入：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n<p>然后输入注释，这个最关键，不能遗漏，中文英文都可以，以后查看的时候就知道这一次提交的是什么代码，方便查找，输入：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;这是第一次更新demo&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 双引号里面必须写注释，不能省略，否则会报错</span></span><br></pre></td></tr></table></figure>\n<p>接下来就本地库与远程仓库链接起来，打开你最开始建立的仓库，点击code，你会发现一个仓库地址，直接复制这个地址，然后输入指令，<font color=\"red\">在指令后面粘贴刚才复制的地址</font></p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin + 地址</span><br></pre></td></tr></table></figure>\n<p>最后将文件上传到云端，也就是最开始在github创建的仓库，直接输入指令</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n<p>OK，完成，这时候你打开github的时候就会发现需要上传到的文件已经在库里了。</p>\n<p>进入setting界面，往下滑可以看到github pages</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/a68823f5-0135-4010-9abb-11adb0473b0c.png\"></p>\n<p>接下来就是打开网站，shuxhan.github.io，我们直接在网址中输入它，然后打开，因为网速问题可能就会几分钟才能刷新出来，来看看成功之后的界面吧</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6e14340a-1761-48ce-b283-7b19c98fd164.png\"></p>\n<p>OK，网站成功建立，接下来就可以自己随意的往里面添加内容啦！</p>\n<h2 id=\"4-第四步：更新仓库\"><a href=\"#4-第四步：更新仓库\" class=\"headerlink\" title=\"4 第四步：更新仓库\"></a>4 第四步：更新仓库</h2><p>每次写完一篇博客我们要更新到网站上，这里推送在Git的步骤和之前不太一样</p>\n<p>在桌面右键点击git bash here，输入</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone +仓库地址</span><br></pre></td></tr></table></figure>\n<p>将桌面生成的文件夹里面除了.git之外的所有内容删除，差不多就是清空了，因为.git是上传用的文件夹所以留着</p>\n<p>然后将本地的代码文件和文件夹全部粘贴到clone下来的文件夹里</p>\n<p>在该文件夹中右键git bash here,同步仓库信息，输入：</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull origin master</span><br></pre></td></tr></table></figure>\n<p>接下来就是上传代码到本地仓库</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 上传文件</span></span><br><span class=\"line\"> </span><br><span class=\"line\">git commit -m &quot;&quot;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 添加备注</span></span><br></pre></td></tr></table></figure>\n<p>push到云端仓库</p>\n<figure class=\"highlight shell\"><figcaption><span>shell</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n<p>网站很容易就可以建设，最重要的是其中的内容，希望自己可以坚持一直记录博客，不能半途而废！</p>\n<p>书山有路勤为径，学海无涯苦作舟！</p>"},{"title":"推荐书籍《CSS世界》","date":"2020-09-10T16:00:00.000Z","_content":"\n本书从前端开发人员的需求出发，以“流”为线索，从结构、内容到美化装饰灯方面，全面且深入地讲解前端开发人员必须了解和掌握的大量的CSS知识点。同时，作者结合多年的从业经验，通过大量的实战案例，详尽解析CSS的相关知识与常见问题。\n<!-- more -->\n作者还为本书开发了专门的配套网站，进行实例展示。问题答疑。作为一本CSS深度学习的书，书中介绍大量许多前端开发人员都不知道的CSS知识点。通过阅读本书，读者会对CSS世界的深度和广度有一个全新的认识。\n\n这本书作者采用口语化的方式，讲述在css中遇到的一些有意思的问题，循序渐进，引人入胜，对有前端基础的人来说，读这本书还是很有意思的。我经常在闲余时间看看这本书，会给我一些启发。\n","source":"_posts/20200911-cssworld.md","raw":"---\ntitle: 推荐书籍《CSS世界》\ndate: 2020-9-11\ncategories: 随笔文章\n---\n\n本书从前端开发人员的需求出发，以“流”为线索，从结构、内容到美化装饰灯方面，全面且深入地讲解前端开发人员必须了解和掌握的大量的CSS知识点。同时，作者结合多年的从业经验，通过大量的实战案例，详尽解析CSS的相关知识与常见问题。\n<!-- more -->\n作者还为本书开发了专门的配套网站，进行实例展示。问题答疑。作为一本CSS深度学习的书，书中介绍大量许多前端开发人员都不知道的CSS知识点。通过阅读本书，读者会对CSS世界的深度和广度有一个全新的认识。\n\n这本书作者采用口语化的方式，讲述在css中遇到的一些有意思的问题，循序渐进，引人入胜，对有前端基础的人来说，读这本书还是很有意思的。我经常在闲余时间看看这本书，会给我一些启发。\n","slug":"20200911-cssworld","published":1,"updated":"2020-12-14T09:59:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6t0gyc0003s6f05uox3v0a","content":"<p>本书从前端开发人员的需求出发，以“流”为线索，从结构、内容到美化装饰灯方面，全面且深入地讲解前端开发人员必须了解和掌握的大量的CSS知识点。同时，作者结合多年的从业经验，通过大量的实战案例，详尽解析CSS的相关知识与常见问题。</p>\n<a id=\"more\"></a>\n<p>作者还为本书开发了专门的配套网站，进行实例展示。问题答疑。作为一本CSS深度学习的书，书中介绍大量许多前端开发人员都不知道的CSS知识点。通过阅读本书，读者会对CSS世界的深度和广度有一个全新的认识。</p>\n<p>这本书作者采用口语化的方式，讲述在css中遇到的一些有意思的问题，循序渐进，引人入胜，对有前端基础的人来说，读这本书还是很有意思的。我经常在闲余时间看看这本书，会给我一些启发。</p>\n","site":{"data":{}},"length":301,"excerpt":"<p>本书从前端开发人员的需求出发，以“流”为线索，从结构、内容到美化装饰灯方面，全面且深入地讲解前端开发人员必须了解和掌握的大量的CSS知识点。同时，作者结合多年的从业经验，通过大量的实战案例，详尽解析CSS的相关知识与常见问题。</p>","more":"<p>作者还为本书开发了专门的配套网站，进行实例展示。问题答疑。作为一本CSS深度学习的书，书中介绍大量许多前端开发人员都不知道的CSS知识点。通过阅读本书，读者会对CSS世界的深度和广度有一个全新的认识。</p>\n<p>这本书作者采用口语化的方式，讲述在css中遇到的一些有意思的问题，循序渐进，引人入胜，对有前端基础的人来说，读这本书还是很有意思的。我经常在闲余时间看看这本书，会给我一些启发。</p>"},{"title":"对全栈的一些思考","date":"2020-09-17T16:00:00.000Z","_content":"\n这里我要推荐一本书，叫做《Web全栈工程师的自我修养》，在看的过程中，自己也代入进去进行分析，然后写了这篇笔记。\n<!-- more -->\n“全栈工程师正在成为IT行业的新秀，无论是在上市互联网公司还是在创业公司，都对全栈工程师青睐有加。本书作者是腾讯公 司高级工程师，在前端、后端和APP开发方面都有丰富的经验，在本书中分享了全栈工程师的技能与要求、核心竞争力、未来发 展方向、对移动端的思考。除此之外，本书还详细记录了作者从零开始、学习心得。本书内容全面、客观务实适合互联网行业新人 、程序员。以及期待技术转型的从业者阅读参考。”\n\n作者余果毕业于西安点击科技大学软件工程学院，曾任腾讯社交用户体验设计部高级UI工程师、前端开发负责人，负责多个项目的产品设计，以自身的经历为模板撰写了这本书。\n\n从自身说起，因为对技术和机器的热爱让他走向了计算机这门行业，而在书中，他也经常提及自己理性和感性思维相结合，对全栈工程师进行了深入分析。\n\n全栈工程师是指一个能够处理数据库、服务器、系统工程和客户端所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web栈，或者原生应用程序栈。这是官方的定义。而以我目前出入前端的思维通俗点来说，大概也就是一个人包揽前端，后端，一个人处理数据进行项目维护，甚至于设计图都是自己做的。\n\n很多人都说全栈有很多好处，不同担心很多人编写不同步，思维不一致，导致做出来的项目每个人的想法不同，全栈一个人包揽所有的过程，都在自己脑子里。\n\n可能因为我进入这个行业不久，我认为全栈是不太合理的存在，打个比方说，在流水线还没出现之间，手工作坊基本都是一个人负责所有的产品制作，从原料，制作，打磨，成品，或许很经过很多步骤，但是一个人都可以完美的做出来，就这样类似全栈工程师这样的存在。\n\n而生产线就更像一个团队，产品，UI，前端，后端测试等，每个人相互配合。\n\n全栈和团队比起来，我个人觉得团队的优势更大，但架不住老板喜欢一个人干三个人活，更喜欢全栈一点。\n\n培养一个全栈的花费的时间和精力难以想象，甚至不确定培养一定成功，但是如果专精某一技术领域，成为高级工程师的概率绝对远大于一个全栈。当然这也只是我个人的臆测，并没有具体的数据支撑。\n\n书中也提及，流水线带来的另一个好处，不会对某个工程师产生依赖性，即使失去这个员工，也可以让被人接手工作\n\n说了很多团队化的好处，这不代表就没有弊端，肯定是有的，书中总结出来几点：\n\n* 工程师职责不清导致效率低 \n* 工程师缺乏主人感导致产品质量差\n* 工程师缺乏全局的视野影响个人成长\n* 更多角色导致项目效率低下\n\n“因为各司其职的工作流程有效率低下、成本高的缺点，所以很多创业公司都不会配备齐全的流水线，而是希望采用更灵活的方式来组建团队，全栈工程师也因此成为了理想的选择。但是全栈工程师的兴起还离不开这两个重要因素：技术的发展，以及提供PaaS服务的平台越来越多。”\n\n虽然做成为一个全栈工程师需要耗费大量的时间精力来打磨，但是这个思维我还是比较喜欢的。比如说，有a,b,c三个人，分别擅长各自的领域，有一天他们共同负责的项目出了一个小问题，但是问题出在哪里领域还不知道，虽然是个小问题，但需要每个人去查验一遍，因为是三个领域，这就导致应该有两个人的查验是无效的，这从另一个方向来说也降低了项目效率。\n\n然后这时候，有一个工程师s，注意他不是全栈工程师，只是喜欢学习多领域的技术，掌握了一些不算太高深的技术知识，查验了一遍，很快就找出了问题所在。\n\n那他一个人效率就相当于三个的效率了，其实这样说并不严谨，我也只是打个比方。\n\n\n\n我突然想到一句话，不知道说的准确与否，\n\n“全栈的职位存在是不合理的，但全栈的思维是一个有上进心的工程师所必备的。”\n","source":"_posts/20200918-weber.md","raw":"---\ntitle: 对全栈的一些思考\ndate: 2020-09-18\ncategories: 随笔文章\n---\n\n这里我要推荐一本书，叫做《Web全栈工程师的自我修养》，在看的过程中，自己也代入进去进行分析，然后写了这篇笔记。\n<!-- more -->\n“全栈工程师正在成为IT行业的新秀，无论是在上市互联网公司还是在创业公司，都对全栈工程师青睐有加。本书作者是腾讯公 司高级工程师，在前端、后端和APP开发方面都有丰富的经验，在本书中分享了全栈工程师的技能与要求、核心竞争力、未来发 展方向、对移动端的思考。除此之外，本书还详细记录了作者从零开始、学习心得。本书内容全面、客观务实适合互联网行业新人 、程序员。以及期待技术转型的从业者阅读参考。”\n\n作者余果毕业于西安点击科技大学软件工程学院，曾任腾讯社交用户体验设计部高级UI工程师、前端开发负责人，负责多个项目的产品设计，以自身的经历为模板撰写了这本书。\n\n从自身说起，因为对技术和机器的热爱让他走向了计算机这门行业，而在书中，他也经常提及自己理性和感性思维相结合，对全栈工程师进行了深入分析。\n\n全栈工程师是指一个能够处理数据库、服务器、系统工程和客户端所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web栈，或者原生应用程序栈。这是官方的定义。而以我目前出入前端的思维通俗点来说，大概也就是一个人包揽前端，后端，一个人处理数据进行项目维护，甚至于设计图都是自己做的。\n\n很多人都说全栈有很多好处，不同担心很多人编写不同步，思维不一致，导致做出来的项目每个人的想法不同，全栈一个人包揽所有的过程，都在自己脑子里。\n\n可能因为我进入这个行业不久，我认为全栈是不太合理的存在，打个比方说，在流水线还没出现之间，手工作坊基本都是一个人负责所有的产品制作，从原料，制作，打磨，成品，或许很经过很多步骤，但是一个人都可以完美的做出来，就这样类似全栈工程师这样的存在。\n\n而生产线就更像一个团队，产品，UI，前端，后端测试等，每个人相互配合。\n\n全栈和团队比起来，我个人觉得团队的优势更大，但架不住老板喜欢一个人干三个人活，更喜欢全栈一点。\n\n培养一个全栈的花费的时间和精力难以想象，甚至不确定培养一定成功，但是如果专精某一技术领域，成为高级工程师的概率绝对远大于一个全栈。当然这也只是我个人的臆测，并没有具体的数据支撑。\n\n书中也提及，流水线带来的另一个好处，不会对某个工程师产生依赖性，即使失去这个员工，也可以让被人接手工作\n\n说了很多团队化的好处，这不代表就没有弊端，肯定是有的，书中总结出来几点：\n\n* 工程师职责不清导致效率低 \n* 工程师缺乏主人感导致产品质量差\n* 工程师缺乏全局的视野影响个人成长\n* 更多角色导致项目效率低下\n\n“因为各司其职的工作流程有效率低下、成本高的缺点，所以很多创业公司都不会配备齐全的流水线，而是希望采用更灵活的方式来组建团队，全栈工程师也因此成为了理想的选择。但是全栈工程师的兴起还离不开这两个重要因素：技术的发展，以及提供PaaS服务的平台越来越多。”\n\n虽然做成为一个全栈工程师需要耗费大量的时间精力来打磨，但是这个思维我还是比较喜欢的。比如说，有a,b,c三个人，分别擅长各自的领域，有一天他们共同负责的项目出了一个小问题，但是问题出在哪里领域还不知道，虽然是个小问题，但需要每个人去查验一遍，因为是三个领域，这就导致应该有两个人的查验是无效的，这从另一个方向来说也降低了项目效率。\n\n然后这时候，有一个工程师s，注意他不是全栈工程师，只是喜欢学习多领域的技术，掌握了一些不算太高深的技术知识，查验了一遍，很快就找出了问题所在。\n\n那他一个人效率就相当于三个的效率了，其实这样说并不严谨，我也只是打个比方。\n\n\n\n我突然想到一句话，不知道说的准确与否，\n\n“全栈的职位存在是不合理的，但全栈的思维是一个有上进心的工程师所必备的。”\n","slug":"20200918-weber","published":1,"updated":"2020-12-14T09:59:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6t0gyh0007s6f06s8o0b46","content":"<p>这里我要推荐一本书，叫做《Web全栈工程师的自我修养》，在看的过程中，自己也代入进去进行分析，然后写了这篇笔记。</p>\n<a id=\"more\"></a>\n<p>“全栈工程师正在成为IT行业的新秀，无论是在上市互联网公司还是在创业公司，都对全栈工程师青睐有加。本书作者是腾讯公 司高级工程师，在前端、后端和APP开发方面都有丰富的经验，在本书中分享了全栈工程师的技能与要求、核心竞争力、未来发 展方向、对移动端的思考。除此之外，本书还详细记录了作者从零开始、学习心得。本书内容全面、客观务实适合互联网行业新人 、程序员。以及期待技术转型的从业者阅读参考。”</p>\n<p>作者余果毕业于西安点击科技大学软件工程学院，曾任腾讯社交用户体验设计部高级UI工程师、前端开发负责人，负责多个项目的产品设计，以自身的经历为模板撰写了这本书。</p>\n<p>从自身说起，因为对技术和机器的热爱让他走向了计算机这门行业，而在书中，他也经常提及自己理性和感性思维相结合，对全栈工程师进行了深入分析。</p>\n<p>全栈工程师是指一个能够处理数据库、服务器、系统工程和客户端所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web栈，或者原生应用程序栈。这是官方的定义。而以我目前出入前端的思维通俗点来说，大概也就是一个人包揽前端，后端，一个人处理数据进行项目维护，甚至于设计图都是自己做的。</p>\n<p>很多人都说全栈有很多好处，不同担心很多人编写不同步，思维不一致，导致做出来的项目每个人的想法不同，全栈一个人包揽所有的过程，都在自己脑子里。</p>\n<p>可能因为我进入这个行业不久，我认为全栈是不太合理的存在，打个比方说，在流水线还没出现之间，手工作坊基本都是一个人负责所有的产品制作，从原料，制作，打磨，成品，或许很经过很多步骤，但是一个人都可以完美的做出来，就这样类似全栈工程师这样的存在。</p>\n<p>而生产线就更像一个团队，产品，UI，前端，后端测试等，每个人相互配合。</p>\n<p>全栈和团队比起来，我个人觉得团队的优势更大，但架不住老板喜欢一个人干三个人活，更喜欢全栈一点。</p>\n<p>培养一个全栈的花费的时间和精力难以想象，甚至不确定培养一定成功，但是如果专精某一技术领域，成为高级工程师的概率绝对远大于一个全栈。当然这也只是我个人的臆测，并没有具体的数据支撑。</p>\n<p>书中也提及，流水线带来的另一个好处，不会对某个工程师产生依赖性，即使失去这个员工，也可以让被人接手工作</p>\n<p>说了很多团队化的好处，这不代表就没有弊端，肯定是有的，书中总结出来几点：</p>\n<ul>\n<li>工程师职责不清导致效率低 </li>\n<li>工程师缺乏主人感导致产品质量差</li>\n<li>工程师缺乏全局的视野影响个人成长</li>\n<li>更多角色导致项目效率低下</li>\n</ul>\n<p>“因为各司其职的工作流程有效率低下、成本高的缺点，所以很多创业公司都不会配备齐全的流水线，而是希望采用更灵活的方式来组建团队，全栈工程师也因此成为了理想的选择。但是全栈工程师的兴起还离不开这两个重要因素：技术的发展，以及提供PaaS服务的平台越来越多。”</p>\n<p>虽然做成为一个全栈工程师需要耗费大量的时间精力来打磨，但是这个思维我还是比较喜欢的。比如说，有a,b,c三个人，分别擅长各自的领域，有一天他们共同负责的项目出了一个小问题，但是问题出在哪里领域还不知道，虽然是个小问题，但需要每个人去查验一遍，因为是三个领域，这就导致应该有两个人的查验是无效的，这从另一个方向来说也降低了项目效率。</p>\n<p>然后这时候，有一个工程师s，注意他不是全栈工程师，只是喜欢学习多领域的技术，掌握了一些不算太高深的技术知识，查验了一遍，很快就找出了问题所在。</p>\n<p>那他一个人效率就相当于三个的效率了，其实这样说并不严谨，我也只是打个比方。</p>\n<p>我突然想到一句话，不知道说的准确与否，</p>\n<p>“全栈的职位存在是不合理的，但全栈的思维是一个有上进心的工程师所必备的。”</p>\n","site":{"data":{}},"length":1498,"excerpt":"<p>这里我要推荐一本书，叫做《Web全栈工程师的自我修养》，在看的过程中，自己也代入进去进行分析，然后写了这篇笔记。</p>","more":"<p>“全栈工程师正在成为IT行业的新秀，无论是在上市互联网公司还是在创业公司，都对全栈工程师青睐有加。本书作者是腾讯公 司高级工程师，在前端、后端和APP开发方面都有丰富的经验，在本书中分享了全栈工程师的技能与要求、核心竞争力、未来发 展方向、对移动端的思考。除此之外，本书还详细记录了作者从零开始、学习心得。本书内容全面、客观务实适合互联网行业新人 、程序员。以及期待技术转型的从业者阅读参考。”</p>\n<p>作者余果毕业于西安点击科技大学软件工程学院，曾任腾讯社交用户体验设计部高级UI工程师、前端开发负责人，负责多个项目的产品设计，以自身的经历为模板撰写了这本书。</p>\n<p>从自身说起，因为对技术和机器的热爱让他走向了计算机这门行业，而在书中，他也经常提及自己理性和感性思维相结合，对全栈工程师进行了深入分析。</p>\n<p>全栈工程师是指一个能够处理数据库、服务器、系统工程和客户端所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web栈，或者原生应用程序栈。这是官方的定义。而以我目前出入前端的思维通俗点来说，大概也就是一个人包揽前端，后端，一个人处理数据进行项目维护，甚至于设计图都是自己做的。</p>\n<p>很多人都说全栈有很多好处，不同担心很多人编写不同步，思维不一致，导致做出来的项目每个人的想法不同，全栈一个人包揽所有的过程，都在自己脑子里。</p>\n<p>可能因为我进入这个行业不久，我认为全栈是不太合理的存在，打个比方说，在流水线还没出现之间，手工作坊基本都是一个人负责所有的产品制作，从原料，制作，打磨，成品，或许很经过很多步骤，但是一个人都可以完美的做出来，就这样类似全栈工程师这样的存在。</p>\n<p>而生产线就更像一个团队，产品，UI，前端，后端测试等，每个人相互配合。</p>\n<p>全栈和团队比起来，我个人觉得团队的优势更大，但架不住老板喜欢一个人干三个人活，更喜欢全栈一点。</p>\n<p>培养一个全栈的花费的时间和精力难以想象，甚至不确定培养一定成功，但是如果专精某一技术领域，成为高级工程师的概率绝对远大于一个全栈。当然这也只是我个人的臆测，并没有具体的数据支撑。</p>\n<p>书中也提及，流水线带来的另一个好处，不会对某个工程师产生依赖性，即使失去这个员工，也可以让被人接手工作</p>\n<p>说了很多团队化的好处，这不代表就没有弊端，肯定是有的，书中总结出来几点：</p>\n<ul>\n<li>工程师职责不清导致效率低 </li>\n<li>工程师缺乏主人感导致产品质量差</li>\n<li>工程师缺乏全局的视野影响个人成长</li>\n<li>更多角色导致项目效率低下</li>\n</ul>\n<p>“因为各司其职的工作流程有效率低下、成本高的缺点，所以很多创业公司都不会配备齐全的流水线，而是希望采用更灵活的方式来组建团队，全栈工程师也因此成为了理想的选择。但是全栈工程师的兴起还离不开这两个重要因素：技术的发展，以及提供PaaS服务的平台越来越多。”</p>\n<p>虽然做成为一个全栈工程师需要耗费大量的时间精力来打磨，但是这个思维我还是比较喜欢的。比如说，有a,b,c三个人，分别擅长各自的领域，有一天他们共同负责的项目出了一个小问题，但是问题出在哪里领域还不知道，虽然是个小问题，但需要每个人去查验一遍，因为是三个领域，这就导致应该有两个人的查验是无效的，这从另一个方向来说也降低了项目效率。</p>\n<p>然后这时候，有一个工程师s，注意他不是全栈工程师，只是喜欢学习多领域的技术，掌握了一些不算太高深的技术知识，查验了一遍，很快就找出了问题所在。</p>\n<p>那他一个人效率就相当于三个的效率了，其实这样说并不严谨，我也只是打个比方。</p>\n<p>我突然想到一句话，不知道说的准确与否，</p>\n<p>“全栈的职位存在是不合理的，但全栈的思维是一个有上进心的工程师所必备的。”</p>"},{"title":"github pages怎么自定义域名？","date":"2020-10-12T16:00:00.000Z","_content":"\n之前说过怎么基于 github pages 搭建静态网站，但是网站后面显示 github.io ，有些不太美观，这篇文章教你怎么自定义域名。\n\n接之间的一篇博客，我写了这一篇文章，附上链接[《基于github pages搭建静态网站》](../20200902-static)\n\n<!-- more -->\n\n---\n\n看一下 github pages 文档，发现 github 非常贴心的解决了这个问题， gitee 之前有这个功能，但是目前下架了，估计也是遥遥无期，所以就用 github 来自定义域名吧！\n\ngithub免费给我们提供了一个存放内容的空间，但是域名就需要我们自己购买了，国内的用户可以选择在[阿里云](https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.45.19e14f15PNrJL7)，[腾讯云](https://dnspod.cloud.tencent.com/s)，西部数码等网站上购买域名。\n\n我选择的是阿里云。\n\n常规的注册账号之后，然后进行实名认证，按照步骤一步一步来就可以了。\n\n然后选择一个心仪的域名，一般 com 后缀的域名比较受欢迎，但是价位和可选择性就没那么高了，我本来想用自己的名字，但是已经被注册了，so选择的缩写`shuxhan.com` 。\n\n购买的时候，我们要绑定个人的身份，前面说到了实名认证，简单的绑定一下个人身份即可，这里就不细说了。\n\n购买以后，等个几分钟认证成功之后就可以去解析了。\n\n在控制台里面点击域名，在自己的域名后面点击解析，然后点击新手引导，就会弹出下面这个窗口。\n\n![custom-1.png](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/c6212a36-e0e4-4d3f-9f01-6081ed169d43.png)。\n\n在记录值中输入本机的 github 仓库 IP 地址，每个地区不一样，可以直接百度本机github 仓库 IP地址。\n\n比如我的本机github 仓库 IP地址是185.199.108.153。\n\n我直接在记录值中输入它，然后点击确认就行了，大概几分钟以后就可以解析完成。\n\n接下来我们回到自己的github仓库中，点击settings滑到github pages界面。\n\n在红色框内输入自己解析过的域名，然后点击save，顺便勾选一下下面那个https。\n\n![custom-2.png](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/59b2b1b0-a936-449d-8e48-e2469fe8a1fe.png)。\n\n刷新一下页面，回到github pages就会发现原来那个github.io后缀的网址，变成了我们自己想要的域名。\n\n操作挺简单的，就是注意细节不要弄错，半个小时就可以搞定。\n\n**其他**\n\n上面那些步骤完成之后，回到仓库列表就会发现，自动生成一个 `CNAME` 的文件，域名就放在该文件里。\n\n有一个弊端，当我们使用 hexo 建立博客的时候，有一个 `hexo d` 的指令，推送文章到仓库中，每次推送都会把 `CNAME` 重置掉。\n\n所以，为了方便，建议自己在本地的博客文件夹根目录的 `source 文件夹` 下新建一个 `CNAME` 文件，里面写上自己要绑定的域名即可。\n\n>注意: `CNAME`不带后缀，就一个光秃秃的`CNAME`，如果没有打开文件后缀显示的小伙伴一定要注意了。\n\n![custom-3.png](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6b45bf1d-35f4-4d0e-a1b2-bebf5d9c8ed0.png)\n\n这样就OK啦！\n\n以后每次推送新的内容的时候，会自动绑定自定义的域名。","source":"_posts/20201013-custom.md","raw":"---\ntitle: github pages怎么自定义域名？\ndate: 2020-10-13\ntags: 建站手册及问题\ncategories: 其他\n---\n\n之前说过怎么基于 github pages 搭建静态网站，但是网站后面显示 github.io ，有些不太美观，这篇文章教你怎么自定义域名。\n\n接之间的一篇博客，我写了这一篇文章，附上链接[《基于github pages搭建静态网站》](../20200902-static)\n\n<!-- more -->\n\n---\n\n看一下 github pages 文档，发现 github 非常贴心的解决了这个问题， gitee 之前有这个功能，但是目前下架了，估计也是遥遥无期，所以就用 github 来自定义域名吧！\n\ngithub免费给我们提供了一个存放内容的空间，但是域名就需要我们自己购买了，国内的用户可以选择在[阿里云](https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.45.19e14f15PNrJL7)，[腾讯云](https://dnspod.cloud.tencent.com/s)，西部数码等网站上购买域名。\n\n我选择的是阿里云。\n\n常规的注册账号之后，然后进行实名认证，按照步骤一步一步来就可以了。\n\n然后选择一个心仪的域名，一般 com 后缀的域名比较受欢迎，但是价位和可选择性就没那么高了，我本来想用自己的名字，但是已经被注册了，so选择的缩写`shuxhan.com` 。\n\n购买的时候，我们要绑定个人的身份，前面说到了实名认证，简单的绑定一下个人身份即可，这里就不细说了。\n\n购买以后，等个几分钟认证成功之后就可以去解析了。\n\n在控制台里面点击域名，在自己的域名后面点击解析，然后点击新手引导，就会弹出下面这个窗口。\n\n![custom-1.png](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/c6212a36-e0e4-4d3f-9f01-6081ed169d43.png)。\n\n在记录值中输入本机的 github 仓库 IP 地址，每个地区不一样，可以直接百度本机github 仓库 IP地址。\n\n比如我的本机github 仓库 IP地址是185.199.108.153。\n\n我直接在记录值中输入它，然后点击确认就行了，大概几分钟以后就可以解析完成。\n\n接下来我们回到自己的github仓库中，点击settings滑到github pages界面。\n\n在红色框内输入自己解析过的域名，然后点击save，顺便勾选一下下面那个https。\n\n![custom-2.png](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/59b2b1b0-a936-449d-8e48-e2469fe8a1fe.png)。\n\n刷新一下页面，回到github pages就会发现原来那个github.io后缀的网址，变成了我们自己想要的域名。\n\n操作挺简单的，就是注意细节不要弄错，半个小时就可以搞定。\n\n**其他**\n\n上面那些步骤完成之后，回到仓库列表就会发现，自动生成一个 `CNAME` 的文件，域名就放在该文件里。\n\n有一个弊端，当我们使用 hexo 建立博客的时候，有一个 `hexo d` 的指令，推送文章到仓库中，每次推送都会把 `CNAME` 重置掉。\n\n所以，为了方便，建议自己在本地的博客文件夹根目录的 `source 文件夹` 下新建一个 `CNAME` 文件，里面写上自己要绑定的域名即可。\n\n>注意: `CNAME`不带后缀，就一个光秃秃的`CNAME`，如果没有打开文件后缀显示的小伙伴一定要注意了。\n\n![custom-3.png](https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6b45bf1d-35f4-4d0e-a1b2-bebf5d9c8ed0.png)\n\n这样就OK啦！\n\n以后每次推送新的内容的时候，会自动绑定自定义的域名。","slug":"20201013-custom","published":1,"updated":"2021-01-13T05:50:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6t0gyj0009s6f0eakoaw4j","content":"<p>之前说过怎么基于 github pages 搭建静态网站，但是网站后面显示 github.io ，有些不太美观，这篇文章教你怎么自定义域名。</p>\n<p>接之间的一篇博客，我写了这一篇文章，附上链接<a href=\"../20200902-static\">《基于github pages搭建静态网站》</a></p>\n<a id=\"more\"></a>\n\n<hr>\n<p>看一下 github pages 文档，发现 github 非常贴心的解决了这个问题， gitee 之前有这个功能，但是目前下架了，估计也是遥遥无期，所以就用 github 来自定义域名吧！</p>\n<p>github免费给我们提供了一个存放内容的空间，但是域名就需要我们自己购买了，国内的用户可以选择在<a href=\"https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.45.19e14f15PNrJL7\">阿里云</a>，<a href=\"https://dnspod.cloud.tencent.com/s\">腾讯云</a>，西部数码等网站上购买域名。</p>\n<p>我选择的是阿里云。</p>\n<p>常规的注册账号之后，然后进行实名认证，按照步骤一步一步来就可以了。</p>\n<p>然后选择一个心仪的域名，一般 com 后缀的域名比较受欢迎，但是价位和可选择性就没那么高了，我本来想用自己的名字，但是已经被注册了，so选择的缩写<code>shuxhan.com</code> 。</p>\n<p>购买的时候，我们要绑定个人的身份，前面说到了实名认证，简单的绑定一下个人身份即可，这里就不细说了。</p>\n<p>购买以后，等个几分钟认证成功之后就可以去解析了。</p>\n<p>在控制台里面点击域名，在自己的域名后面点击解析，然后点击新手引导，就会弹出下面这个窗口。</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/c6212a36-e0e4-4d3f-9f01-6081ed169d43.png\" alt=\"custom-1.png\">。</p>\n<p>在记录值中输入本机的 github 仓库 IP 地址，每个地区不一样，可以直接百度本机github 仓库 IP地址。</p>\n<p>比如我的本机github 仓库 IP地址是185.199.108.153。</p>\n<p>我直接在记录值中输入它，然后点击确认就行了，大概几分钟以后就可以解析完成。</p>\n<p>接下来我们回到自己的github仓库中，点击settings滑到github pages界面。</p>\n<p>在红色框内输入自己解析过的域名，然后点击save，顺便勾选一下下面那个https。</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/59b2b1b0-a936-449d-8e48-e2469fe8a1fe.png\" alt=\"custom-2.png\">。</p>\n<p>刷新一下页面，回到github pages就会发现原来那个github.io后缀的网址，变成了我们自己想要的域名。</p>\n<p>操作挺简单的，就是注意细节不要弄错，半个小时就可以搞定。</p>\n<p><strong>其他</strong></p>\n<p>上面那些步骤完成之后，回到仓库列表就会发现，自动生成一个 <code>CNAME</code> 的文件，域名就放在该文件里。</p>\n<p>有一个弊端，当我们使用 hexo 建立博客的时候，有一个 <code>hexo d</code> 的指令，推送文章到仓库中，每次推送都会把 <code>CNAME</code> 重置掉。</p>\n<p>所以，为了方便，建议自己在本地的博客文件夹根目录的 <code>source 文件夹</code> 下新建一个 <code>CNAME</code> 文件，里面写上自己要绑定的域名即可。</p>\n<blockquote>\n<p>注意: <code>CNAME</code>不带后缀，就一个光秃秃的<code>CNAME</code>，如果没有打开文件后缀显示的小伙伴一定要注意了。</p>\n</blockquote>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6b45bf1d-35f4-4d0e-a1b2-bebf5d9c8ed0.png\" alt=\"custom-3.png\"></p>\n<p>这样就OK啦！</p>\n<p>以后每次推送新的内容的时候，会自动绑定自定义的域名。</p>\n","site":{"data":{}},"length":1056,"excerpt":"<p>之前说过怎么基于 github pages 搭建静态网站，但是网站后面显示 github.io ，有些不太美观，这篇文章教你怎么自定义域名。</p>\n<p>接之间的一篇博客，我写了这一篇文章，附上链接<a href=\"../20200902-static\">《基于github pages搭建静态网站》</a></p>","more":"<hr>\n<p>看一下 github pages 文档，发现 github 非常贴心的解决了这个问题， gitee 之前有这个功能，但是目前下架了，估计也是遥遥无期，所以就用 github 来自定义域名吧！</p>\n<p>github免费给我们提供了一个存放内容的空间，但是域名就需要我们自己购买了，国内的用户可以选择在<a href=\"https://wanwang.aliyun.com/domain/?spm=5176.100251.111252.45.19e14f15PNrJL7\">阿里云</a>，<a href=\"https://dnspod.cloud.tencent.com/s\">腾讯云</a>，西部数码等网站上购买域名。</p>\n<p>我选择的是阿里云。</p>\n<p>常规的注册账号之后，然后进行实名认证，按照步骤一步一步来就可以了。</p>\n<p>然后选择一个心仪的域名，一般 com 后缀的域名比较受欢迎，但是价位和可选择性就没那么高了，我本来想用自己的名字，但是已经被注册了，so选择的缩写<code>shuxhan.com</code> 。</p>\n<p>购买的时候，我们要绑定个人的身份，前面说到了实名认证，简单的绑定一下个人身份即可，这里就不细说了。</p>\n<p>购买以后，等个几分钟认证成功之后就可以去解析了。</p>\n<p>在控制台里面点击域名，在自己的域名后面点击解析，然后点击新手引导，就会弹出下面这个窗口。</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/c6212a36-e0e4-4d3f-9f01-6081ed169d43.png\" alt=\"custom-1.png\">。</p>\n<p>在记录值中输入本机的 github 仓库 IP 地址，每个地区不一样，可以直接百度本机github 仓库 IP地址。</p>\n<p>比如我的本机github 仓库 IP地址是185.199.108.153。</p>\n<p>我直接在记录值中输入它，然后点击确认就行了，大概几分钟以后就可以解析完成。</p>\n<p>接下来我们回到自己的github仓库中，点击settings滑到github pages界面。</p>\n<p>在红色框内输入自己解析过的域名，然后点击save，顺便勾选一下下面那个https。</p>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/59b2b1b0-a936-449d-8e48-e2469fe8a1fe.png\" alt=\"custom-2.png\">。</p>\n<p>刷新一下页面，回到github pages就会发现原来那个github.io后缀的网址，变成了我们自己想要的域名。</p>\n<p>操作挺简单的，就是注意细节不要弄错，半个小时就可以搞定。</p>\n<p><strong>其他</strong></p>\n<p>上面那些步骤完成之后，回到仓库列表就会发现，自动生成一个 <code>CNAME</code> 的文件，域名就放在该文件里。</p>\n<p>有一个弊端，当我们使用 hexo 建立博客的时候，有一个 <code>hexo d</code> 的指令，推送文章到仓库中，每次推送都会把 <code>CNAME</code> 重置掉。</p>\n<p>所以，为了方便，建议自己在本地的博客文件夹根目录的 <code>source 文件夹</code> 下新建一个 <code>CNAME</code> 文件，里面写上自己要绑定的域名即可。</p>\n<blockquote>\n<p>注意: <code>CNAME</code>不带后缀，就一个光秃秃的<code>CNAME</code>，如果没有打开文件后缀显示的小伙伴一定要注意了。</p>\n</blockquote>\n<p><img src=\"https://vkceyugu.cdn.bspapp.com/VKCEYUGU-imgbed/6b45bf1d-35f4-4d0e-a1b2-bebf5d9c8ed0.png\" alt=\"custom-3.png\"></p>\n<p>这样就OK啦！</p>\n<p>以后每次推送新的内容的时候，会自动绑定自定义的域名。</p>"},{"title":"使用 React 与 Vue 创建同一款 App，差别究竟有多大？","date":"2021-01-05T16:00:00.000Z","toc":true,"cover":"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143024.jpg","_content":"\n关于 [React 框架](https://react.docschina.org/) 和 [Vue 框架](https://cn.vuejs.org/) 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？\n<!-- more -->\n\n>转载于：https://blog.csdn.net/csdnnews/article/details/81880378\n>原文：https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd \n>作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。 \n>译者：安翔，责编：屠敏\n\n众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。\n\n于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。\n\n很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。 \n\n## 1.目标\n\n我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面） 构建，React 使用 create-react-app，Vue 使用 vue-cli。\n\n两个应用程序的外观如下： \n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143025.jpg)\n\n两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构： \n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143026.jpg)\n\n你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。\n\n两种不同的策略得到的结果是一样的，相信开发者很快能够掌握这两种不同的策略。开发者可以根据自己的偏好做出选择，你会听到开发社区关于如何构建 CSS 的大量讨论。以上，我们遵循两个 CLI 列出了代码结构。\n\n在我们进一步讨论之前，先快速看一下典型的 Vue 和 React 组件的外观：\n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143027.jpg)\n\n现在让我们正式开始，深入其中的细节！\n\n## 2.如何修改数据\n\n首先，我们需要明白“修改数据”的意思是什么。它听起来有些学术，但实际上很简单，就是把我们已经存储好的数据进行更改。比如，如果我们想把一个人的名字变量从“Jhon”改为“Mark”，我们就需要执行“修改数据”的操作。在这一点上，React 和 Vue 的处理方式有所区别。Vue 本质上会创建一个数据对象，其中的数据可以自由更改；React 则创建一个状态对象，更改数据需要一些额外的操作。React 之所以需要额外的操作有着自己的理由，稍后我会深入介绍。在此之前，我们先看看 Vue 中的数据对象和 React 中的状态对象： \n\n**vue 数据对象**\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143028.jpg)\n\n**React 状态对象**\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143029.jpg)\n\n从图中可以看出，我们传入了相同的数据，但它们的标记方法不同。因此，将初始数据传递到组件的方式非常相似。但正如我们提到的那样，在两个框架中更改数据的方式有所不同。\n\n假设我们有一个名为 name: ‘Sunil’ 的数据元素。\n\n在 Vue 中，我们通过调用 this.name 来引用它。我们也可以通过调用 this.name ='John' 来更新它。这样一来，名字就被成功改为了 “Jhon”。\n\n在 React 中，我们通过调用 this.state.name 来引用同一段数据。现在关键的区别在于，我们不能简单地写成 this.state.name ='John'，因为 React 有限制机制，它会阻止这种简单的修改方式。在 React 中，我们需要这样写：this.setState({name：'John'})。\n\n虽然这基本上与我们在 Vue 中实现的结果一样，但是 React 的操作更为繁琐，那是因为 Vue 在每次更新数据时默认组合了自己的 setState 版本。 简单来说就是，React 需要 setState，然后更新其内部数据，而对于 Vue 来说，当你更新数据对象的值时它就默认了你的更改意图。 那么为什么 React 没有进行简化，为什么需要 setState 呢？ Revanth Kumar 对此做出了解释：\n\n>“这是因为 React 希望在状态发生变化时重新运行某些生命周期 hook，比如 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate。当你调用 setState 函数时，它知道状态已经改变。如果你直接改变状态，React 将需要做更多工作来跟踪更改以及运行生命周期 hook 等等。所以为了简单起见，React 使用 setState。\" \n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143030.jpg)\n\n## 3.添加新的待办事项\n\n### React 的实现方法\n\n```js\ncreateNewToDoItem = () => {\n    this.setState( ({ list, todo }) => ({\n      list: [\n          ...list,\n        {\n          todo\n        }\n      ],\n      todo: ''\n    })\n  );\n};\n```\n\n在 React 中，我们的输入字段有一个名为 value 的属性。这个 value 通过使用几个函数自动更新，这些函数绑定在一起以创建双向绑定。我们通过在输入字段上附加一个 onChange 事件监听器来创建这种形式的双向绑定。看看代码，一探究竟：\n\n```html\n<input type=\"text\" \n       value={this.state.todo} \n       onChange={this.handleInput}/>\n```\n\n只要输入字段的值发生更改，handleInput 函数就会运行。它通过将状态对象设置为输入字段中的任何内容来更新状态对象内的 todo。handleInput 函数如下：\n\n```js\nhandleInput = e => {\n  this.setState({\n    todo: e.target.value\n  });\n};\n```\n\n现在，只要用户按下页面上的 + 按钮添加新项目，createNewToDoItem 函数就会运行 this.setState 并向其传递一个函数。该函数有两个参数，第一个是来自状态对象的整个列表数组，第二个是由 handleInput 函数更新的todo。然后该函数返回一个新对象，该对象包含之前的整个列表，并在其末尾添加todo。整个列表是通过使用扩展运算符添加的。\n\n最后，我们将 todo 设置为空字符串，它会自动更新输入字段中的 value。\n\n### Vue 的实现方法\n\n```js\ncreateNewToDoItem() {\n    this.list.push(\n        {\n            'todo': this.todo\n        }\n    );\n    this.todo = '';\n}\n```\n\n在 Vue 中，我们的输入字段中有一个名为 v-model 的句柄。这实现了**双向绑定。输入字段代码如下：\n\n```html\n<input type=\"text\" v-model=\"todo\"/>\n```\n\nV-Model 将输入字段的内容绑定到名为 toDoItem 的数据对象的键（key）上。当页面加载时，我们将 toDoItem 设置为空字符串，比如：todo：' '。如果已经存在数据，例如 todo：'添加文本处'，输入字段将加载添加文本处的输入内容。无论如何，将其作为空字符串，我们在输入字段中键入的任何文本都会绑定到 todo。这实际上是双向绑定（输入字段可以更新数据对象，数据对象可以更新输入字段）。\n\n因此，回顾前面的 createNewToDoItem() 代码块，我们将 todo 的内容存放到列表数组中 ，然后将 todo 改为空字符串。\n\n## 4.删除待办事项\n\n### React 的实现方法\n\n```js\ndeleteItem = indexToDelete => {\n    this.setState(({ list }) => ({\n      list: list.filter((toDo, index) => index !== indexToDelete)\n    }));\n};\n```\n\n尽管 deleteItem 函数位于 ToDo.js 文件中，但是从 ToDoItem.js 文件中引用它也很容易，将 deleteItem() 函数作为 上的 prop 传递：\n\n```js\n<ToDoItem deleteItem={this.deleteItem.bind(this, key)}/>\n```\n\n这会将该函数传递给子组件，使其可以访问。我们绑定了 this 并传递 key 参数，当用户点击删除项时，函数通过 key 区分用户点击的是哪一条 ToDoItem 。然后，在ToDoItem 组件内部，我们执行以下操作：\n\n```html\n<div className=”ToDoItem-Delete” onClick={this.props.deleteItem}>-</div> \n```\n\n想要引用位于父组件内部的函数，只需引用 this.props.deleteItem 即可。\n\n### Vue 的实现方法\n\n```js\nonDeleteItem(todo){\n  this.list = this.list.filter(item => item !== todo);\n}\n```\n\nVue 的实现方法稍有不同，我们需要做到以下三点：\n\n1. 首先，在元素上调用函数：\n\n```html\n<div class=”ToDoItem-Delete” @click=”deleteItem(todo)”>-</div>\n```\n\n2. 然后我们必须创建一个 emit 函数，将其作为子组件的内部方法（在本例中为ToDoItem.vue），如下所示：\n\n```js\ndeleteItem(todo) {\n    this.$emit('delete', todo)\n}\n```\n\n3. 之后，你会发现，当我们添加 ToDo.vue的 ToDoItem.vue 时，实际上引用了一个函数：\n\n```js\n<ToDoItem v-for=\"todo in list\" \n\t:todo=\"todo\" \n\t@delete=\"onDeleteItem\" // <-- this :)\n\t:key=\"todo.id\" />\n```\n\n这就是所谓的自定义事件监听器。它会监听任何使用 'delete' 字符串的触发事件。一旦监听到事件，它会触发一个名为 onDeleteItem 的函数。此函数位于 ToDo.vue 内部，而不是 ToDoItem.vue。如前所述，该函数只是过滤数据对象内的 todo 数组 ，以删除被点击的待办事项。\n\n在 Vue 示例中还需要注意的是，我们可以在 @click 侦听器中编写 $emit 部分，这样更加简单，如下所示：\n\n```html\n<div class=”ToDoItem-Delete” @click=”$emit(‘delete’, todo)”>-</div> \n```\n\n如果你喜欢，这样做可以把 3 步减少到 2 步。\n\nReact 中的子组件可以通过 this.props 访问父函数，而在 Vue 中，你需要从子组件中发出事件，父组件来收集事件。\n\n## 5.如何传递事件监听器\n\n### React 的实现方法\n\n事件监听器处理简单事件（比如点击）非常直接。我们为待办事项创建了点击事件，用于创建新的待办事项，代码如下： \n\n```html\n<div className=”ToDo-Add” onClick={this.createNewToDoItem}>+</div>\n```\n\n非常简单，就像使用 vanilla JS 处理内联 onClick 一样。正如前文所述，只要按下回车按钮，设置事件监听器就需要花费更长的时间。这需要输入标签处理 onKeyPress 事件，代码如下：\n\n```html\n<input type=”text” onKeyPress={this.handleKeyPress}/>\n```\n\n该函数只要识别到'enter'键被按下，它就会触发 **createNewToDoItem** 函数，代码如下所示：\n\n```js\nhandleKeyPress = (e) => {\n  if (e.key === ‘Enter’) {\n\t\tthis.createNewToDoItem();\n\t}\n};\n```\n\n### Vue 的实现方法\n\nVue 的事件监听器更加直接。我们只需要使用一个简单的 @ 符号，就可以构建出我们想要的事件监听器。例如，想要添加 click 事件监听器，代码：\n\n```html\n<div class=”ToDo-Add” @click=”createNewToDoItem()”>+</div> \n```\n\n>注意：@click 实际上是 v-on:click 的简写。Vue 事件监听器很强大，你可以为其选择属性，例如 .once 可以防止事件监听器被多次触发。此外，它还包含很多快捷方式。按下回车按钮时，React 就需要花费更长的时间来创建事件监听器，从而创建新的 ToDo 项目。在 Vue，代码如下：\n\n```html\n<input type=”text” v-on:keyup.enter=”createNewToDoItem”/>\n```\n\n## 6.如何将数据传递给子组件\n\n### React 的实现方法\n\n在 React 中，我们将 props 传递到子组件的创建处。比如：\n\n```js\n<ToDoItem key={key} item={todo} />\n```\n\n此处我们向 ToDoItem 组件传递了两个 prop。之后，我们可以在子组件中通过 this.props 引用它们。因此，想要访问 item.todo prop，我们只需调用this.props.item 。\n\n### Vue 的实现方法\n\n在 Vue 中，我们将 props 传递到子组件创建处的方式如下：\n\n```js\n<ToDoItem v-for=\"todo in list\" \n\t:todo=\"todo\"\n\t:key=\"todo.id\"\n\t@delete=\"onDeleteItem\" />\n```\n\n我们将它们传递给子组件中的 props 数组，如：props：['id'，'todo']。然后可以在子组件中通过名字引用它们。\n\n## 7.如何将数据发送回父组件\n\n### React 的实现方法\n\n我们首先将函数传递给子组件，方法是在我们调用子组件时将其引用为 prop。然后我们通过引用 this.props.whateverTheFunctionIsCalled，为子组件添加调用函数，例如 onClick。然后，这将触发父组件中的函数。删除待办事项一节中详细介绍了整个过程。\n\n### Vue 的实现方法\n\n在子组件中我们只需编写一个函数，将一个值发送回父函数。在父组件中编写一个函数来监听子组件何时发出该值的事件，监听到事件之后触发函数调用。同样，删除待办事项一节中详细介绍了整个过程。\n\n## 8.总结\n\n我们研究了添加、删除和更改数据，以 prop 形式从父组件到子组件传递数据，以及通过事件监听器的形式将数据从子组件发送到父组件。当然，React 和 Vue 之间存在一些小差异，希望本文的内容有助于理解这两个框架。\n\n两个应用程序的 GitHub 地址：\n\n**Vue ToDo：**https://github.com/sunil-sandhu/vue-todo\n\n**React ToDo：**https://github.com/sunil-sandhu/react-todo","source":"_posts/20210106-vue-react-difference.md","raw":"---\ntitle: 使用 React 与 Vue 创建同一款 App，差别究竟有多大？\ndate: 2021-01-06\ncategories: 前端技术\ntoc: true\ncover: https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143024.jpg\n---\n\n关于 [React 框架](https://react.docschina.org/) 和 [Vue 框架](https://cn.vuejs.org/) 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？\n<!-- more -->\n\n>转载于：https://blog.csdn.net/csdnnews/article/details/81880378\n>原文：https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd \n>作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。 \n>译者：安翔，责编：屠敏\n\n众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。\n\n于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。\n\n很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。 \n\n## 1.目标\n\n我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面） 构建，React 使用 create-react-app，Vue 使用 vue-cli。\n\n两个应用程序的外观如下： \n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143025.jpg)\n\n两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构： \n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143026.jpg)\n\n你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。\n\n两种不同的策略得到的结果是一样的，相信开发者很快能够掌握这两种不同的策略。开发者可以根据自己的偏好做出选择，你会听到开发社区关于如何构建 CSS 的大量讨论。以上，我们遵循两个 CLI 列出了代码结构。\n\n在我们进一步讨论之前，先快速看一下典型的 Vue 和 React 组件的外观：\n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143027.jpg)\n\n现在让我们正式开始，深入其中的细节！\n\n## 2.如何修改数据\n\n首先，我们需要明白“修改数据”的意思是什么。它听起来有些学术，但实际上很简单，就是把我们已经存储好的数据进行更改。比如，如果我们想把一个人的名字变量从“Jhon”改为“Mark”，我们就需要执行“修改数据”的操作。在这一点上，React 和 Vue 的处理方式有所区别。Vue 本质上会创建一个数据对象，其中的数据可以自由更改；React 则创建一个状态对象，更改数据需要一些额外的操作。React 之所以需要额外的操作有着自己的理由，稍后我会深入介绍。在此之前，我们先看看 Vue 中的数据对象和 React 中的状态对象： \n\n**vue 数据对象**\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143028.jpg)\n\n**React 状态对象**\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143029.jpg)\n\n从图中可以看出，我们传入了相同的数据，但它们的标记方法不同。因此，将初始数据传递到组件的方式非常相似。但正如我们提到的那样，在两个框架中更改数据的方式有所不同。\n\n假设我们有一个名为 name: ‘Sunil’ 的数据元素。\n\n在 Vue 中，我们通过调用 this.name 来引用它。我们也可以通过调用 this.name ='John' 来更新它。这样一来，名字就被成功改为了 “Jhon”。\n\n在 React 中，我们通过调用 this.state.name 来引用同一段数据。现在关键的区别在于，我们不能简单地写成 this.state.name ='John'，因为 React 有限制机制，它会阻止这种简单的修改方式。在 React 中，我们需要这样写：this.setState({name：'John'})。\n\n虽然这基本上与我们在 Vue 中实现的结果一样，但是 React 的操作更为繁琐，那是因为 Vue 在每次更新数据时默认组合了自己的 setState 版本。 简单来说就是，React 需要 setState，然后更新其内部数据，而对于 Vue 来说，当你更新数据对象的值时它就默认了你的更改意图。 那么为什么 React 没有进行简化，为什么需要 setState 呢？ Revanth Kumar 对此做出了解释：\n\n>“这是因为 React 希望在状态发生变化时重新运行某些生命周期 hook，比如 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate。当你调用 setState 函数时，它知道状态已经改变。如果你直接改变状态，React 将需要做更多工作来跟踪更改以及运行生命周期 hook 等等。所以为了简单起见，React 使用 setState。\" \n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143030.jpg)\n\n## 3.添加新的待办事项\n\n### React 的实现方法\n\n```js\ncreateNewToDoItem = () => {\n    this.setState( ({ list, todo }) => ({\n      list: [\n          ...list,\n        {\n          todo\n        }\n      ],\n      todo: ''\n    })\n  );\n};\n```\n\n在 React 中，我们的输入字段有一个名为 value 的属性。这个 value 通过使用几个函数自动更新，这些函数绑定在一起以创建双向绑定。我们通过在输入字段上附加一个 onChange 事件监听器来创建这种形式的双向绑定。看看代码，一探究竟：\n\n```html\n<input type=\"text\" \n       value={this.state.todo} \n       onChange={this.handleInput}/>\n```\n\n只要输入字段的值发生更改，handleInput 函数就会运行。它通过将状态对象设置为输入字段中的任何内容来更新状态对象内的 todo。handleInput 函数如下：\n\n```js\nhandleInput = e => {\n  this.setState({\n    todo: e.target.value\n  });\n};\n```\n\n现在，只要用户按下页面上的 + 按钮添加新项目，createNewToDoItem 函数就会运行 this.setState 并向其传递一个函数。该函数有两个参数，第一个是来自状态对象的整个列表数组，第二个是由 handleInput 函数更新的todo。然后该函数返回一个新对象，该对象包含之前的整个列表，并在其末尾添加todo。整个列表是通过使用扩展运算符添加的。\n\n最后，我们将 todo 设置为空字符串，它会自动更新输入字段中的 value。\n\n### Vue 的实现方法\n\n```js\ncreateNewToDoItem() {\n    this.list.push(\n        {\n            'todo': this.todo\n        }\n    );\n    this.todo = '';\n}\n```\n\n在 Vue 中，我们的输入字段中有一个名为 v-model 的句柄。这实现了**双向绑定。输入字段代码如下：\n\n```html\n<input type=\"text\" v-model=\"todo\"/>\n```\n\nV-Model 将输入字段的内容绑定到名为 toDoItem 的数据对象的键（key）上。当页面加载时，我们将 toDoItem 设置为空字符串，比如：todo：' '。如果已经存在数据，例如 todo：'添加文本处'，输入字段将加载添加文本处的输入内容。无论如何，将其作为空字符串，我们在输入字段中键入的任何文本都会绑定到 todo。这实际上是双向绑定（输入字段可以更新数据对象，数据对象可以更新输入字段）。\n\n因此，回顾前面的 createNewToDoItem() 代码块，我们将 todo 的内容存放到列表数组中 ，然后将 todo 改为空字符串。\n\n## 4.删除待办事项\n\n### React 的实现方法\n\n```js\ndeleteItem = indexToDelete => {\n    this.setState(({ list }) => ({\n      list: list.filter((toDo, index) => index !== indexToDelete)\n    }));\n};\n```\n\n尽管 deleteItem 函数位于 ToDo.js 文件中，但是从 ToDoItem.js 文件中引用它也很容易，将 deleteItem() 函数作为 上的 prop 传递：\n\n```js\n<ToDoItem deleteItem={this.deleteItem.bind(this, key)}/>\n```\n\n这会将该函数传递给子组件，使其可以访问。我们绑定了 this 并传递 key 参数，当用户点击删除项时，函数通过 key 区分用户点击的是哪一条 ToDoItem 。然后，在ToDoItem 组件内部，我们执行以下操作：\n\n```html\n<div className=”ToDoItem-Delete” onClick={this.props.deleteItem}>-</div> \n```\n\n想要引用位于父组件内部的函数，只需引用 this.props.deleteItem 即可。\n\n### Vue 的实现方法\n\n```js\nonDeleteItem(todo){\n  this.list = this.list.filter(item => item !== todo);\n}\n```\n\nVue 的实现方法稍有不同，我们需要做到以下三点：\n\n1. 首先，在元素上调用函数：\n\n```html\n<div class=”ToDoItem-Delete” @click=”deleteItem(todo)”>-</div>\n```\n\n2. 然后我们必须创建一个 emit 函数，将其作为子组件的内部方法（在本例中为ToDoItem.vue），如下所示：\n\n```js\ndeleteItem(todo) {\n    this.$emit('delete', todo)\n}\n```\n\n3. 之后，你会发现，当我们添加 ToDo.vue的 ToDoItem.vue 时，实际上引用了一个函数：\n\n```js\n<ToDoItem v-for=\"todo in list\" \n\t:todo=\"todo\" \n\t@delete=\"onDeleteItem\" // <-- this :)\n\t:key=\"todo.id\" />\n```\n\n这就是所谓的自定义事件监听器。它会监听任何使用 'delete' 字符串的触发事件。一旦监听到事件，它会触发一个名为 onDeleteItem 的函数。此函数位于 ToDo.vue 内部，而不是 ToDoItem.vue。如前所述，该函数只是过滤数据对象内的 todo 数组 ，以删除被点击的待办事项。\n\n在 Vue 示例中还需要注意的是，我们可以在 @click 侦听器中编写 $emit 部分，这样更加简单，如下所示：\n\n```html\n<div class=”ToDoItem-Delete” @click=”$emit(‘delete’, todo)”>-</div> \n```\n\n如果你喜欢，这样做可以把 3 步减少到 2 步。\n\nReact 中的子组件可以通过 this.props 访问父函数，而在 Vue 中，你需要从子组件中发出事件，父组件来收集事件。\n\n## 5.如何传递事件监听器\n\n### React 的实现方法\n\n事件监听器处理简单事件（比如点击）非常直接。我们为待办事项创建了点击事件，用于创建新的待办事项，代码如下： \n\n```html\n<div className=”ToDo-Add” onClick={this.createNewToDoItem}>+</div>\n```\n\n非常简单，就像使用 vanilla JS 处理内联 onClick 一样。正如前文所述，只要按下回车按钮，设置事件监听器就需要花费更长的时间。这需要输入标签处理 onKeyPress 事件，代码如下：\n\n```html\n<input type=”text” onKeyPress={this.handleKeyPress}/>\n```\n\n该函数只要识别到'enter'键被按下，它就会触发 **createNewToDoItem** 函数，代码如下所示：\n\n```js\nhandleKeyPress = (e) => {\n  if (e.key === ‘Enter’) {\n\t\tthis.createNewToDoItem();\n\t}\n};\n```\n\n### Vue 的实现方法\n\nVue 的事件监听器更加直接。我们只需要使用一个简单的 @ 符号，就可以构建出我们想要的事件监听器。例如，想要添加 click 事件监听器，代码：\n\n```html\n<div class=”ToDo-Add” @click=”createNewToDoItem()”>+</div> \n```\n\n>注意：@click 实际上是 v-on:click 的简写。Vue 事件监听器很强大，你可以为其选择属性，例如 .once 可以防止事件监听器被多次触发。此外，它还包含很多快捷方式。按下回车按钮时，React 就需要花费更长的时间来创建事件监听器，从而创建新的 ToDo 项目。在 Vue，代码如下：\n\n```html\n<input type=”text” v-on:keyup.enter=”createNewToDoItem”/>\n```\n\n## 6.如何将数据传递给子组件\n\n### React 的实现方法\n\n在 React 中，我们将 props 传递到子组件的创建处。比如：\n\n```js\n<ToDoItem key={key} item={todo} />\n```\n\n此处我们向 ToDoItem 组件传递了两个 prop。之后，我们可以在子组件中通过 this.props 引用它们。因此，想要访问 item.todo prop，我们只需调用this.props.item 。\n\n### Vue 的实现方法\n\n在 Vue 中，我们将 props 传递到子组件创建处的方式如下：\n\n```js\n<ToDoItem v-for=\"todo in list\" \n\t:todo=\"todo\"\n\t:key=\"todo.id\"\n\t@delete=\"onDeleteItem\" />\n```\n\n我们将它们传递给子组件中的 props 数组，如：props：['id'，'todo']。然后可以在子组件中通过名字引用它们。\n\n## 7.如何将数据发送回父组件\n\n### React 的实现方法\n\n我们首先将函数传递给子组件，方法是在我们调用子组件时将其引用为 prop。然后我们通过引用 this.props.whateverTheFunctionIsCalled，为子组件添加调用函数，例如 onClick。然后，这将触发父组件中的函数。删除待办事项一节中详细介绍了整个过程。\n\n### Vue 的实现方法\n\n在子组件中我们只需编写一个函数，将一个值发送回父函数。在父组件中编写一个函数来监听子组件何时发出该值的事件，监听到事件之后触发函数调用。同样，删除待办事项一节中详细介绍了整个过程。\n\n## 8.总结\n\n我们研究了添加、删除和更改数据，以 prop 形式从父组件到子组件传递数据，以及通过事件监听器的形式将数据从子组件发送到父组件。当然，React 和 Vue 之间存在一些小差异，希望本文的内容有助于理解这两个框架。\n\n两个应用程序的 GitHub 地址：\n\n**Vue ToDo：**https://github.com/sunil-sandhu/vue-todo\n\n**React ToDo：**https://github.com/sunil-sandhu/react-todo","slug":"20210106-vue-react-difference","published":1,"updated":"2021-01-11T08:19:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6t0gyl000bs6f021aj5apg","content":"<p>关于 <a href=\"https://react.docschina.org/\">React 框架</a> 和 <a href=\"https://cn.vuejs.org/\">Vue 框架</a> 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>转载于：<a href=\"https://blog.csdn.net/csdnnews/article/details/81880378\">https://blog.csdn.net/csdnnews/article/details/81880378</a><br>原文：<a href=\"https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd\">https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd</a><br>作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。<br>译者：安翔，责编：屠敏</p>\n</blockquote>\n<p>众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。</p>\n<p>于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。</p>\n<p>很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。 </p>\n<h2 id=\"1-目标\"><a href=\"#1-目标\" class=\"headerlink\" title=\"1.目标\"></a>1.目标</h2><p>我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面） 构建，React 使用 create-react-app，Vue 使用 vue-cli。</p>\n<p>两个应用程序的外观如下： </p>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143025.jpg\"></p>\n<p>两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构： </p>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143026.jpg\"></p>\n<p>你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。</p>\n<p>两种不同的策略得到的结果是一样的，相信开发者很快能够掌握这两种不同的策略。开发者可以根据自己的偏好做出选择，你会听到开发社区关于如何构建 CSS 的大量讨论。以上，我们遵循两个 CLI 列出了代码结构。</p>\n<p>在我们进一步讨论之前，先快速看一下典型的 Vue 和 React 组件的外观：</p>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143027.jpg\"></p>\n<p>现在让我们正式开始，深入其中的细节！</p>\n<h2 id=\"2-如何修改数据\"><a href=\"#2-如何修改数据\" class=\"headerlink\" title=\"2.如何修改数据\"></a>2.如何修改数据</h2><p>首先，我们需要明白“修改数据”的意思是什么。它听起来有些学术，但实际上很简单，就是把我们已经存储好的数据进行更改。比如，如果我们想把一个人的名字变量从“Jhon”改为“Mark”，我们就需要执行“修改数据”的操作。在这一点上，React 和 Vue 的处理方式有所区别。Vue 本质上会创建一个数据对象，其中的数据可以自由更改；React 则创建一个状态对象，更改数据需要一些额外的操作。React 之所以需要额外的操作有着自己的理由，稍后我会深入介绍。在此之前，我们先看看 Vue 中的数据对象和 React 中的状态对象： </p>\n<p><strong>vue 数据对象</strong><br><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143028.jpg\"></p>\n<p><strong>React 状态对象</strong><br><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143029.jpg\"></p>\n<p>从图中可以看出，我们传入了相同的数据，但它们的标记方法不同。因此，将初始数据传递到组件的方式非常相似。但正如我们提到的那样，在两个框架中更改数据的方式有所不同。</p>\n<p>假设我们有一个名为 name: ‘Sunil’ 的数据元素。</p>\n<p>在 Vue 中，我们通过调用 this.name 来引用它。我们也可以通过调用 this.name =’John’ 来更新它。这样一来，名字就被成功改为了 “Jhon”。</p>\n<p>在 React 中，我们通过调用 this.state.name 来引用同一段数据。现在关键的区别在于，我们不能简单地写成 this.state.name =’John’，因为 React 有限制机制，它会阻止这种简单的修改方式。在 React 中，我们需要这样写：this.setState({name：’John’})。</p>\n<p>虽然这基本上与我们在 Vue 中实现的结果一样，但是 React 的操作更为繁琐，那是因为 Vue 在每次更新数据时默认组合了自己的 setState 版本。 简单来说就是，React 需要 setState，然后更新其内部数据，而对于 Vue 来说，当你更新数据对象的值时它就默认了你的更改意图。 那么为什么 React 没有进行简化，为什么需要 setState 呢？ Revanth Kumar 对此做出了解释：</p>\n<blockquote>\n<p>“这是因为 React 希望在状态发生变化时重新运行某些生命周期 hook，比如 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate。当你调用 setState 函数时，它知道状态已经改变。如果你直接改变状态，React 将需要做更多工作来跟踪更改以及运行生命周期 hook 等等。所以为了简单起见，React 使用 setState。” </p>\n</blockquote>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143030.jpg\"></p>\n<h2 id=\"3-添加新的待办事项\"><a href=\"#3-添加新的待办事项\" class=\"headerlink\" title=\"3.添加新的待办事项\"></a>3.添加新的待办事项</h2><h3 id=\"React-的实现方法\"><a href=\"#React-的实现方法\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createNewToDoItem = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState( <span class=\"function\">(<span class=\"params\">&#123; list, todo &#125;</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">      list: [</span><br><span class=\"line\">          ...list,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          todo</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      todo: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 React 中，我们的输入字段有一个名为 value 的属性。这个 value 通过使用几个函数自动更新，这些函数绑定在一起以创建双向绑定。我们通过在输入字段上附加一个 onChange 事件监听器来创建这种形式的双向绑定。看看代码，一探究竟：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.todo&#125;</span> </span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.handleInput&#125;/</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>只要输入字段的值发生更改，handleInput 函数就会运行。它通过将状态对象设置为输入字段中的任何内容来更新状态对象内的 todo。handleInput 函数如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleInput = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.setState(&#123;</span><br><span class=\"line\">    todo: e.target.value</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>现在，只要用户按下页面上的 + 按钮添加新项目，createNewToDoItem 函数就会运行 this.setState 并向其传递一个函数。该函数有两个参数，第一个是来自状态对象的整个列表数组，第二个是由 handleInput 函数更新的todo。然后该函数返回一个新对象，该对象包含之前的整个列表，并在其末尾添加todo。整个列表是通过使用扩展运算符添加的。</p>\n<p>最后，我们将 todo 设置为空字符串，它会自动更新输入字段中的 value。</p>\n<h3 id=\"Vue-的实现方法\"><a href=\"#Vue-的实现方法\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">createNewToDoItem</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.list.push(</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;todo&#x27;</span>: <span class=\"built_in\">this</span>.todo</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.todo = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Vue 中，我们的输入字段中有一个名为 v-model 的句柄。这实现了**双向绑定。输入字段代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;todo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>V-Model 将输入字段的内容绑定到名为 toDoItem 的数据对象的键（key）上。当页面加载时，我们将 toDoItem 设置为空字符串，比如：todo：’ ‘。如果已经存在数据，例如 todo：’添加文本处’，输入字段将加载添加文本处的输入内容。无论如何，将其作为空字符串，我们在输入字段中键入的任何文本都会绑定到 todo。这实际上是双向绑定（输入字段可以更新数据对象，数据对象可以更新输入字段）。</p>\n<p>因此，回顾前面的 createNewToDoItem() 代码块，我们将 todo 的内容存放到列表数组中 ，然后将 todo 改为空字符串。</p>\n<h2 id=\"4-删除待办事项\"><a href=\"#4-删除待办事项\" class=\"headerlink\" title=\"4.删除待办事项\"></a>4.删除待办事项</h2><h3 id=\"React-的实现方法-1\"><a href=\"#React-的实现方法-1\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deleteItem = <span class=\"function\"><span class=\"params\">indexToDelete</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(<span class=\"function\">(<span class=\"params\">&#123; list &#125;</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">      list: list.filter(<span class=\"function\">(<span class=\"params\">toDo, index</span>) =&gt;</span> index !== indexToDelete)</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>尽管 deleteItem 函数位于 ToDo.js 文件中，但是从 ToDoItem.js 文件中引用它也很容易，将 deleteItem() 函数作为 上的 prop 传递：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ToDoItem deleteItem=&#123;<span class=\"built_in\">this</span>.deleteItem.bind(<span class=\"built_in\">this</span>, key)&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p>这会将该函数传递给子组件，使其可以访问。我们绑定了 this 并传递 key 参数，当用户点击删除项时，函数通过 key 区分用户点击的是哪一条 ToDoItem 。然后，在ToDoItem 组件内部，我们执行以下操作：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">”ToDoItem-Delete”</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.props.deleteItem&#125;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n<p>想要引用位于父组件内部的函数，只需引用 this.props.deleteItem 即可。</p>\n<h3 id=\"Vue-的实现方法-1\"><a href=\"#Vue-的实现方法-1\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">onDeleteItem</span>(<span class=\"params\">todo</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.list = <span class=\"built_in\">this</span>.list.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item !== todo);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vue 的实现方法稍有不同，我们需要做到以下三点：</p>\n<ol>\n<li>首先，在元素上调用函数：</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">”ToDoItem-Delete”</span> @<span class=\"attr\">click</span>=<span class=\"string\">”deleteItem(todo)”</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>然后我们必须创建一个 emit 函数，将其作为子组件的内部方法（在本例中为ToDoItem.vue），如下所示：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">deleteItem</span>(<span class=\"params\">todo</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;delete&#x27;</span>, todo)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>之后，你会发现，当我们添加 ToDo.vue的 ToDoItem.vue 时，实际上引用了一个函数：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ToDoItem v-<span class=\"keyword\">for</span>=<span class=\"string\">&quot;todo in list&quot;</span> </span><br><span class=\"line\">\t:todo=<span class=\"string\">&quot;todo&quot;</span> </span><br><span class=\"line\">\t@<span class=\"keyword\">delete</span>=<span class=\"string\">&quot;onDeleteItem&quot;</span> <span class=\"comment\">// &lt;-- this :)</span></span><br><span class=\"line\">\t:key=<span class=\"string\">&quot;todo.id&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>这就是所谓的自定义事件监听器。它会监听任何使用 ‘delete’ 字符串的触发事件。一旦监听到事件，它会触发一个名为 onDeleteItem 的函数。此函数位于 ToDo.vue 内部，而不是 ToDoItem.vue。如前所述，该函数只是过滤数据对象内的 todo 数组 ，以删除被点击的待办事项。</p>\n<p>在 Vue 示例中还需要注意的是，我们可以在 @click 侦听器中编写 $emit 部分，这样更加简单，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">”ToDoItem-Delete”</span> @<span class=\"attr\">click</span>=<span class=\"string\">”$emit(‘delete’,</span> <span class=\"attr\">todo</span>)”&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n<p>如果你喜欢，这样做可以把 3 步减少到 2 步。</p>\n<p>React 中的子组件可以通过 this.props 访问父函数，而在 Vue 中，你需要从子组件中发出事件，父组件来收集事件。</p>\n<h2 id=\"5-如何传递事件监听器\"><a href=\"#5-如何传递事件监听器\" class=\"headerlink\" title=\"5.如何传递事件监听器\"></a>5.如何传递事件监听器</h2><h3 id=\"React-的实现方法-2\"><a href=\"#React-的实现方法-2\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><p>事件监听器处理简单事件（比如点击）非常直接。我们为待办事项创建了点击事件，用于创建新的待办事项，代码如下： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">”ToDo-Add”</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.createNewToDoItem&#125;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>非常简单，就像使用 vanilla JS 处理内联 onClick 一样。正如前文所述，只要按下回车按钮，设置事件监听器就需要花费更长的时间。这需要输入标签处理 onKeyPress 事件，代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">”text”</span> <span class=\"attr\">onKeyPress</span>=<span class=\"string\">&#123;this.handleKeyPress&#125;/</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该函数只要识别到’enter’键被按下，它就会触发 <strong>createNewToDoItem</strong> 函数，代码如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleKeyPress = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e.key === ‘Enter’) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.createNewToDoItem();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Vue-的实现方法-2\"><a href=\"#Vue-的实现方法-2\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><p>Vue 的事件监听器更加直接。我们只需要使用一个简单的 @ 符号，就可以构建出我们想要的事件监听器。例如，想要添加 click 事件监听器，代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">”ToDo-Add”</span> @<span class=\"attr\">click</span>=<span class=\"string\">”createNewToDoItem()”</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：@click 实际上是 v-on:click 的简写。Vue 事件监听器很强大，你可以为其选择属性，例如 .once 可以防止事件监听器被多次触发。此外，它还包含很多快捷方式。按下回车按钮时，React 就需要花费更长的时间来创建事件监听器，从而创建新的 ToDo 项目。在 Vue，代码如下：</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">”text”</span> <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">”createNewToDoItem”/</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-如何将数据传递给子组件\"><a href=\"#6-如何将数据传递给子组件\" class=\"headerlink\" title=\"6.如何将数据传递给子组件\"></a>6.如何将数据传递给子组件</h2><h3 id=\"React-的实现方法-3\"><a href=\"#React-的实现方法-3\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><p>在 React 中，我们将 props 传递到子组件的创建处。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ToDoItem key=&#123;key&#125; item=&#123;todo&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>此处我们向 ToDoItem 组件传递了两个 prop。之后，我们可以在子组件中通过 this.props 引用它们。因此，想要访问 item.todo prop，我们只需调用this.props.item 。</p>\n<h3 id=\"Vue-的实现方法-3\"><a href=\"#Vue-的实现方法-3\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><p>在 Vue 中，我们将 props 传递到子组件创建处的方式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ToDoItem v-<span class=\"keyword\">for</span>=<span class=\"string\">&quot;todo in list&quot;</span> </span><br><span class=\"line\">\t:todo=<span class=\"string\">&quot;todo&quot;</span></span><br><span class=\"line\">\t:key=<span class=\"string\">&quot;todo.id&quot;</span></span><br><span class=\"line\">\t@<span class=\"keyword\">delete</span>=<span class=\"string\">&quot;onDeleteItem&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>我们将它们传递给子组件中的 props 数组，如：props：[‘id’，’todo’]。然后可以在子组件中通过名字引用它们。</p>\n<h2 id=\"7-如何将数据发送回父组件\"><a href=\"#7-如何将数据发送回父组件\" class=\"headerlink\" title=\"7.如何将数据发送回父组件\"></a>7.如何将数据发送回父组件</h2><h3 id=\"React-的实现方法-4\"><a href=\"#React-的实现方法-4\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><p>我们首先将函数传递给子组件，方法是在我们调用子组件时将其引用为 prop。然后我们通过引用 this.props.whateverTheFunctionIsCalled，为子组件添加调用函数，例如 onClick。然后，这将触发父组件中的函数。删除待办事项一节中详细介绍了整个过程。</p>\n<h3 id=\"Vue-的实现方法-4\"><a href=\"#Vue-的实现方法-4\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><p>在子组件中我们只需编写一个函数，将一个值发送回父函数。在父组件中编写一个函数来监听子组件何时发出该值的事件，监听到事件之后触发函数调用。同样，删除待办事项一节中详细介绍了整个过程。</p>\n<h2 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8.总结\"></a>8.总结</h2><p>我们研究了添加、删除和更改数据，以 prop 形式从父组件到子组件传递数据，以及通过事件监听器的形式将数据从子组件发送到父组件。当然，React 和 Vue 之间存在一些小差异，希望本文的内容有助于理解这两个框架。</p>\n<p>两个应用程序的 GitHub 地址：</p>\n<p><strong>Vue ToDo：</strong><a href=\"https://github.com/sunil-sandhu/vue-todo\">https://github.com/sunil-sandhu/vue-todo</a></p>\n<p><strong>React ToDo：</strong><a href=\"https://github.com/sunil-sandhu/react-todo\">https://github.com/sunil-sandhu/react-todo</a></p>\n","site":{"data":{}},"length":6541,"excerpt":"<p>关于 <a href=\"https://react.docschina.org/\">React 框架</a> 和 <a href=\"https://cn.vuejs.org/\">Vue 框架</a> 的对比，用两者写出同一个程序，对比其代码实现的过程，看看它们的差异究竟有多大？</p>","more":"<blockquote>\n<p>转载于：<a href=\"https://blog.csdn.net/csdnnews/article/details/81880378\">https://blog.csdn.net/csdnnews/article/details/81880378</a><br>原文：<a href=\"https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd\">https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd</a><br>作者简介：Sunil Sandhu，一位 Web 全栈工程师 + 空想家。<br>译者：安翔，责编：屠敏</p>\n</blockquote>\n<p>众所周知，Vue 和 React 都是目前非常著名的前端框架。我在工作中经常使用 Vue，因此我对它有很深入的了解。同时，我也对 React 充满了好奇，想要学习一下，一探究竟。</p>\n<p>于是我阅读了 React 文档并观看了一些视频教程，虽然这些资料很不错，但是我真正想了解的是 React 与 Vue 之间的不同之处。所谓“不同之处”，我并非想知道它们是否都具有虚拟 DOMS 或者它们如何渲染页面，而是希望有人能够从代码的角度解释这两者之间的差异。我想找到一篇解释这些差异的文章，以便 Vue 或者 React 的初学者可以更好地理解它们两者之间的差异。</p>\n<p>很遗憾，我并未找到一篇这样的文章。于是我意识到必须自己动手来比较 Vue 与 React 之间的异同。在我自力更生的过程中，我用这篇文章记录下了具体过程。 </p>\n<h2 id=\"1-目标\"><a href=\"#1-目标\" class=\"headerlink\" title=\"1.目标\"></a>1.目标</h2><p>我将会构建一个标准的待办事项应用程序，允许用户添加和删除列表中的项目。这两个应用程序都使用默认的 CLI（command-line interface，命令行界面） 构建，React 使用 create-react-app，Vue 使用 vue-cli。</p>\n<p>两个应用程序的外观如下： </p>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143025.jpg\"></p>\n<p>两个应用程序的 CSS 代码几乎一样，但这些代码的位置存在差异。考虑到这一点，我们来看看这两个应用程序的文件结构： </p>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143026.jpg\"></p>\n<p>你会发现它们的结构几乎完全相同。唯一的区别在于 React App 拥有三个 CSS 文件，而 Vue App 中没有 CSS 文件。这是因为 React 的 create-react-app 组件需要一个附带文件来保存其样式，而 Vue CLI 采用全包方法，其样式在实际组件文件中声明。</p>\n<p>两种不同的策略得到的结果是一样的，相信开发者很快能够掌握这两种不同的策略。开发者可以根据自己的偏好做出选择，你会听到开发社区关于如何构建 CSS 的大量讨论。以上，我们遵循两个 CLI 列出了代码结构。</p>\n<p>在我们进一步讨论之前，先快速看一下典型的 Vue 和 React 组件的外观：</p>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143027.jpg\"></p>\n<p>现在让我们正式开始，深入其中的细节！</p>\n<h2 id=\"2-如何修改数据\"><a href=\"#2-如何修改数据\" class=\"headerlink\" title=\"2.如何修改数据\"></a>2.如何修改数据</h2><p>首先，我们需要明白“修改数据”的意思是什么。它听起来有些学术，但实际上很简单，就是把我们已经存储好的数据进行更改。比如，如果我们想把一个人的名字变量从“Jhon”改为“Mark”，我们就需要执行“修改数据”的操作。在这一点上，React 和 Vue 的处理方式有所区别。Vue 本质上会创建一个数据对象，其中的数据可以自由更改；React 则创建一个状态对象，更改数据需要一些额外的操作。React 之所以需要额外的操作有着自己的理由，稍后我会深入介绍。在此之前，我们先看看 Vue 中的数据对象和 React 中的状态对象： </p>\n<p><strong>vue 数据对象</strong><br><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143028.jpg\"></p>\n<p><strong>React 状态对象</strong><br><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143029.jpg\"></p>\n<p>从图中可以看出，我们传入了相同的数据，但它们的标记方法不同。因此，将初始数据传递到组件的方式非常相似。但正如我们提到的那样，在两个框架中更改数据的方式有所不同。</p>\n<p>假设我们有一个名为 name: ‘Sunil’ 的数据元素。</p>\n<p>在 Vue 中，我们通过调用 this.name 来引用它。我们也可以通过调用 this.name =’John’ 来更新它。这样一来，名字就被成功改为了 “Jhon”。</p>\n<p>在 React 中，我们通过调用 this.state.name 来引用同一段数据。现在关键的区别在于，我们不能简单地写成 this.state.name =’John’，因为 React 有限制机制，它会阻止这种简单的修改方式。在 React 中，我们需要这样写：this.setState({name：’John’})。</p>\n<p>虽然这基本上与我们在 Vue 中实现的结果一样，但是 React 的操作更为繁琐，那是因为 Vue 在每次更新数据时默认组合了自己的 setState 版本。 简单来说就是，React 需要 setState，然后更新其内部数据，而对于 Vue 来说，当你更新数据对象的值时它就默认了你的更改意图。 那么为什么 React 没有进行简化，为什么需要 setState 呢？ Revanth Kumar 对此做出了解释：</p>\n<blockquote>\n<p>“这是因为 React 希望在状态发生变化时重新运行某些生命周期 hook，比如 componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate。当你调用 setState 函数时，它知道状态已经改变。如果你直接改变状态，React 将需要做更多工作来跟踪更改以及运行生命周期 hook 等等。所以为了简单起见，React 使用 setState。” </p>\n</blockquote>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143030.jpg\"></p>\n<h2 id=\"3-添加新的待办事项\"><a href=\"#3-添加新的待办事项\" class=\"headerlink\" title=\"3.添加新的待办事项\"></a>3.添加新的待办事项</h2><h3 id=\"React-的实现方法\"><a href=\"#React-的实现方法\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">createNewToDoItem = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState( <span class=\"function\">(<span class=\"params\">&#123; list, todo &#125;</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">      list: [</span><br><span class=\"line\">          ...list,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          todo</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      todo: <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 React 中，我们的输入字段有一个名为 value 的属性。这个 value 通过使用几个函数自动更新，这些函数绑定在一起以创建双向绑定。我们通过在输入字段上附加一个 onChange 事件监听器来创建这种形式的双向绑定。看看代码，一探究竟：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> </span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.todo&#125;</span> </span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;this.handleInput&#125;/</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>只要输入字段的值发生更改，handleInput 函数就会运行。它通过将状态对象设置为输入字段中的任何内容来更新状态对象内的 todo。handleInput 函数如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleInput = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.setState(&#123;</span><br><span class=\"line\">    todo: e.target.value</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>现在，只要用户按下页面上的 + 按钮添加新项目，createNewToDoItem 函数就会运行 this.setState 并向其传递一个函数。该函数有两个参数，第一个是来自状态对象的整个列表数组，第二个是由 handleInput 函数更新的todo。然后该函数返回一个新对象，该对象包含之前的整个列表，并在其末尾添加todo。整个列表是通过使用扩展运算符添加的。</p>\n<p>最后，我们将 todo 设置为空字符串，它会自动更新输入字段中的 value。</p>\n<h3 id=\"Vue-的实现方法\"><a href=\"#Vue-的实现方法\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">createNewToDoItem</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.list.push(</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;todo&#x27;</span>: <span class=\"built_in\">this</span>.todo</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.todo = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Vue 中，我们的输入字段中有一个名为 v-model 的句柄。这实现了**双向绑定。输入字段代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">v-model</span>=<span class=\"string\">&quot;todo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>V-Model 将输入字段的内容绑定到名为 toDoItem 的数据对象的键（key）上。当页面加载时，我们将 toDoItem 设置为空字符串，比如：todo：’ ‘。如果已经存在数据，例如 todo：’添加文本处’，输入字段将加载添加文本处的输入内容。无论如何，将其作为空字符串，我们在输入字段中键入的任何文本都会绑定到 todo。这实际上是双向绑定（输入字段可以更新数据对象，数据对象可以更新输入字段）。</p>\n<p>因此，回顾前面的 createNewToDoItem() 代码块，我们将 todo 的内容存放到列表数组中 ，然后将 todo 改为空字符串。</p>\n<h2 id=\"4-删除待办事项\"><a href=\"#4-删除待办事项\" class=\"headerlink\" title=\"4.删除待办事项\"></a>4.删除待办事项</h2><h3 id=\"React-的实现方法-1\"><a href=\"#React-的实现方法-1\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deleteItem = <span class=\"function\"><span class=\"params\">indexToDelete</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(<span class=\"function\">(<span class=\"params\">&#123; list &#125;</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">      list: list.filter(<span class=\"function\">(<span class=\"params\">toDo, index</span>) =&gt;</span> index !== indexToDelete)</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>尽管 deleteItem 函数位于 ToDo.js 文件中，但是从 ToDoItem.js 文件中引用它也很容易，将 deleteItem() 函数作为 上的 prop 传递：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ToDoItem deleteItem=&#123;<span class=\"built_in\">this</span>.deleteItem.bind(<span class=\"built_in\">this</span>, key)&#125;/&gt;</span><br></pre></td></tr></table></figure>\n<p>这会将该函数传递给子组件，使其可以访问。我们绑定了 this 并传递 key 参数，当用户点击删除项时，函数通过 key 区分用户点击的是哪一条 ToDoItem 。然后，在ToDoItem 组件内部，我们执行以下操作：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">”ToDoItem-Delete”</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.props.deleteItem&#125;</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n<p>想要引用位于父组件内部的函数，只需引用 this.props.deleteItem 即可。</p>\n<h3 id=\"Vue-的实现方法-1\"><a href=\"#Vue-的实现方法-1\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">onDeleteItem</span>(<span class=\"params\">todo</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.list = <span class=\"built_in\">this</span>.list.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item !== todo);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vue 的实现方法稍有不同，我们需要做到以下三点：</p>\n<ol>\n<li>首先，在元素上调用函数：</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">”ToDoItem-Delete”</span> @<span class=\"attr\">click</span>=<span class=\"string\">”deleteItem(todo)”</span>&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>然后我们必须创建一个 emit 函数，将其作为子组件的内部方法（在本例中为ToDoItem.vue），如下所示：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">deleteItem</span>(<span class=\"params\">todo</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.$emit(<span class=\"string\">&#x27;delete&#x27;</span>, todo)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>之后，你会发现，当我们添加 ToDo.vue的 ToDoItem.vue 时，实际上引用了一个函数：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ToDoItem v-<span class=\"keyword\">for</span>=<span class=\"string\">&quot;todo in list&quot;</span> </span><br><span class=\"line\">\t:todo=<span class=\"string\">&quot;todo&quot;</span> </span><br><span class=\"line\">\t@<span class=\"keyword\">delete</span>=<span class=\"string\">&quot;onDeleteItem&quot;</span> <span class=\"comment\">// &lt;-- this :)</span></span><br><span class=\"line\">\t:key=<span class=\"string\">&quot;todo.id&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>这就是所谓的自定义事件监听器。它会监听任何使用 ‘delete’ 字符串的触发事件。一旦监听到事件，它会触发一个名为 onDeleteItem 的函数。此函数位于 ToDo.vue 内部，而不是 ToDoItem.vue。如前所述，该函数只是过滤数据对象内的 todo 数组 ，以删除被点击的待办事项。</p>\n<p>在 Vue 示例中还需要注意的是，我们可以在 @click 侦听器中编写 $emit 部分，这样更加简单，如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">”ToDoItem-Delete”</span> @<span class=\"attr\">click</span>=<span class=\"string\">”$emit(‘delete’,</span> <span class=\"attr\">todo</span>)”&gt;</span>-<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n<p>如果你喜欢，这样做可以把 3 步减少到 2 步。</p>\n<p>React 中的子组件可以通过 this.props 访问父函数，而在 Vue 中，你需要从子组件中发出事件，父组件来收集事件。</p>\n<h2 id=\"5-如何传递事件监听器\"><a href=\"#5-如何传递事件监听器\" class=\"headerlink\" title=\"5.如何传递事件监听器\"></a>5.如何传递事件监听器</h2><h3 id=\"React-的实现方法-2\"><a href=\"#React-的实现方法-2\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><p>事件监听器处理简单事件（比如点击）非常直接。我们为待办事项创建了点击事件，用于创建新的待办事项，代码如下： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">”ToDo-Add”</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.createNewToDoItem&#125;</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>非常简单，就像使用 vanilla JS 处理内联 onClick 一样。正如前文所述，只要按下回车按钮，设置事件监听器就需要花费更长的时间。这需要输入标签处理 onKeyPress 事件，代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">”text”</span> <span class=\"attr\">onKeyPress</span>=<span class=\"string\">&#123;this.handleKeyPress&#125;/</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>该函数只要识别到’enter’键被按下，它就会触发 <strong>createNewToDoItem</strong> 函数，代码如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleKeyPress = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e.key === ‘Enter’) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.createNewToDoItem();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Vue-的实现方法-2\"><a href=\"#Vue-的实现方法-2\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><p>Vue 的事件监听器更加直接。我们只需要使用一个简单的 @ 符号，就可以构建出我们想要的事件监听器。例如，想要添加 click 事件监听器，代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">”ToDo-Add”</span> @<span class=\"attr\">click</span>=<span class=\"string\">”createNewToDoItem()”</span>&gt;</span>+<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：@click 实际上是 v-on:click 的简写。Vue 事件监听器很强大，你可以为其选择属性，例如 .once 可以防止事件监听器被多次触发。此外，它还包含很多快捷方式。按下回车按钮时，React 就需要花费更长的时间来创建事件监听器，从而创建新的 ToDo 项目。在 Vue，代码如下：</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">”text”</span> <span class=\"attr\">v-on:keyup.enter</span>=<span class=\"string\">”createNewToDoItem”/</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-如何将数据传递给子组件\"><a href=\"#6-如何将数据传递给子组件\" class=\"headerlink\" title=\"6.如何将数据传递给子组件\"></a>6.如何将数据传递给子组件</h2><h3 id=\"React-的实现方法-3\"><a href=\"#React-的实现方法-3\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><p>在 React 中，我们将 props 传递到子组件的创建处。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ToDoItem key=&#123;key&#125; item=&#123;todo&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>此处我们向 ToDoItem 组件传递了两个 prop。之后，我们可以在子组件中通过 this.props 引用它们。因此，想要访问 item.todo prop，我们只需调用this.props.item 。</p>\n<h3 id=\"Vue-的实现方法-3\"><a href=\"#Vue-的实现方法-3\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><p>在 Vue 中，我们将 props 传递到子组件创建处的方式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ToDoItem v-<span class=\"keyword\">for</span>=<span class=\"string\">&quot;todo in list&quot;</span> </span><br><span class=\"line\">\t:todo=<span class=\"string\">&quot;todo&quot;</span></span><br><span class=\"line\">\t:key=<span class=\"string\">&quot;todo.id&quot;</span></span><br><span class=\"line\">\t@<span class=\"keyword\">delete</span>=<span class=\"string\">&quot;onDeleteItem&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>我们将它们传递给子组件中的 props 数组，如：props：[‘id’，’todo’]。然后可以在子组件中通过名字引用它们。</p>\n<h2 id=\"7-如何将数据发送回父组件\"><a href=\"#7-如何将数据发送回父组件\" class=\"headerlink\" title=\"7.如何将数据发送回父组件\"></a>7.如何将数据发送回父组件</h2><h3 id=\"React-的实现方法-4\"><a href=\"#React-的实现方法-4\" class=\"headerlink\" title=\"React 的实现方法\"></a>React 的实现方法</h3><p>我们首先将函数传递给子组件，方法是在我们调用子组件时将其引用为 prop。然后我们通过引用 this.props.whateverTheFunctionIsCalled，为子组件添加调用函数，例如 onClick。然后，这将触发父组件中的函数。删除待办事项一节中详细介绍了整个过程。</p>\n<h3 id=\"Vue-的实现方法-4\"><a href=\"#Vue-的实现方法-4\" class=\"headerlink\" title=\"Vue 的实现方法\"></a>Vue 的实现方法</h3><p>在子组件中我们只需编写一个函数，将一个值发送回父函数。在父组件中编写一个函数来监听子组件何时发出该值的事件，监听到事件之后触发函数调用。同样，删除待办事项一节中详细介绍了整个过程。</p>\n<h2 id=\"8-总结\"><a href=\"#8-总结\" class=\"headerlink\" title=\"8.总结\"></a>8.总结</h2><p>我们研究了添加、删除和更改数据，以 prop 形式从父组件到子组件传递数据，以及通过事件监听器的形式将数据从子组件发送到父组件。当然，React 和 Vue 之间存在一些小差异，希望本文的内容有助于理解这两个框架。</p>\n<p>两个应用程序的 GitHub 地址：</p>\n<p><strong>Vue ToDo：</strong><a href=\"https://github.com/sunil-sandhu/vue-todo\">https://github.com/sunil-sandhu/vue-todo</a></p>\n<p><strong>React ToDo：</strong><a href=\"https://github.com/sunil-sandhu/react-todo\">https://github.com/sunil-sandhu/react-todo</a></p>"},{"title":"基于 React 的富文本编辑器－－Braft Editor","date":"2021-01-06T16:00:00.000Z","toc":true,"_content":"\n最近发了很多关于 React 的文章，记录遇到的新技术点，以及在写代码过程中遇到的问题，希望可以帮助到和我遇到同样问题的同学。\n\n今天分享的是一款基于 React 的富文本编辑器－－Braft Editor。\n\n<!-- more -->\n\n>Braft Editor 官网：[https://braft.margox.cn](https://braft.margox.cn)\n>Github 仓库地址：[https://github.com/margox/braft-editor](https://github.com/margox/braft-editor)\n\n这款插件非常方便，只需要下载然后引入即可直接使用，页面整体风格清新，符合绝大多数人的审美观，支持图片，音视频的插入。\n\n按照官方的说法，假如你对它的功能还不够满意，不够使用，完全可以扩展它，自己写一个插件来强化他。\n\n经过我的测试，功能绝对强大，可以满足市面上绝大多数的需求。接下来就说一下如何使用这款插件。\n\n## 1.安装\n\n在项目中直接通过 `npm` 或者 `yarn` 下载插件：\n\n```shell\n# 使用 npm 安装\nnpm install braft-editor --save\n\n# 使用 yarn 安装\nyarn add braft-editor\n```\n\n## 2.使用\n\n新建一个组件 `EditorDemo.js`，在里面写入下列代码：\n\n```js\n// EditorDemo.js\n\nimport React from 'react';\nimport BraftEditor from 'braft-editor';\nimport 'braft-editor/dist/index.css';\n\nexport default class PageDemo extends React.Component {\n\n  state = {\n    editorState: BraftEditor.createEditorState(null)\n  }\n\n  render () {\n    return (\n      <BraftEditor value={this.state.editorState} onChange={this.handleChange}/>\n    )\n  }\n\n  handleChange = (editorState) => {\n    this.setState({ editorState })\n  }\n\n}\n```\n\n然后引入到 `index.js` 中去。\n\n## 3.运行\n\n写完组件之后，`npm start` 运行看看效果\n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143022.png)\n\n相当不错，页面很简洁，如果觉得样式不喜欢，完全可以自己重新定制风格，非常方便。\n\n## 4.文档\n\n如果想使用更多功能、方法，进入 [Braft Editor 官方文档](https://www.yuque.com/braft-editor/be/gz44tn)吧，还有更多关于它的讲解！\n\n属性、方法、示例，一应俱全。","source":"_posts/20210107-react-markdown-braft-editor.md","raw":"---\ntitle: 基于 React 的富文本编辑器－－Braft Editor\ndate: 2021-01-07\ntags: [react 杂谈, 组件库]\ncategories: 前端技术\ntoc: true\n---\n\n最近发了很多关于 React 的文章，记录遇到的新技术点，以及在写代码过程中遇到的问题，希望可以帮助到和我遇到同样问题的同学。\n\n今天分享的是一款基于 React 的富文本编辑器－－Braft Editor。\n\n<!-- more -->\n\n>Braft Editor 官网：[https://braft.margox.cn](https://braft.margox.cn)\n>Github 仓库地址：[https://github.com/margox/braft-editor](https://github.com/margox/braft-editor)\n\n这款插件非常方便，只需要下载然后引入即可直接使用，页面整体风格清新，符合绝大多数人的审美观，支持图片，音视频的插入。\n\n按照官方的说法，假如你对它的功能还不够满意，不够使用，完全可以扩展它，自己写一个插件来强化他。\n\n经过我的测试，功能绝对强大，可以满足市面上绝大多数的需求。接下来就说一下如何使用这款插件。\n\n## 1.安装\n\n在项目中直接通过 `npm` 或者 `yarn` 下载插件：\n\n```shell\n# 使用 npm 安装\nnpm install braft-editor --save\n\n# 使用 yarn 安装\nyarn add braft-editor\n```\n\n## 2.使用\n\n新建一个组件 `EditorDemo.js`，在里面写入下列代码：\n\n```js\n// EditorDemo.js\n\nimport React from 'react';\nimport BraftEditor from 'braft-editor';\nimport 'braft-editor/dist/index.css';\n\nexport default class PageDemo extends React.Component {\n\n  state = {\n    editorState: BraftEditor.createEditorState(null)\n  }\n\n  render () {\n    return (\n      <BraftEditor value={this.state.editorState} onChange={this.handleChange}/>\n    )\n  }\n\n  handleChange = (editorState) => {\n    this.setState({ editorState })\n  }\n\n}\n```\n\n然后引入到 `index.js` 中去。\n\n## 3.运行\n\n写完组件之后，`npm start` 运行看看效果\n\n![](https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143022.png)\n\n相当不错，页面很简洁，如果觉得样式不喜欢，完全可以自己重新定制风格，非常方便。\n\n## 4.文档\n\n如果想使用更多功能、方法，进入 [Braft Editor 官方文档](https://www.yuque.com/braft-editor/be/gz44tn)吧，还有更多关于它的讲解！\n\n属性、方法、示例，一应俱全。","slug":"20210107-react-markdown-braft-editor","published":1,"updated":"2021-01-13T07:36:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6t0gyp000fs6f0c1qgfwxt","content":"<p>最近发了很多关于 React 的文章，记录遇到的新技术点，以及在写代码过程中遇到的问题，希望可以帮助到和我遇到同样问题的同学。</p>\n<p>今天分享的是一款基于 React 的富文本编辑器－－Braft Editor。</p>\n<a id=\"more\"></a>\n\n<blockquote>\n<p>Braft Editor 官网：<a href=\"https://braft.margox.cn/\">https://braft.margox.cn</a><br>Github 仓库地址：<a href=\"https://github.com/margox/braft-editor\">https://github.com/margox/braft-editor</a></p>\n</blockquote>\n<p>这款插件非常方便，只需要下载然后引入即可直接使用，页面整体风格清新，符合绝大多数人的审美观，支持图片，音视频的插入。</p>\n<p>按照官方的说法，假如你对它的功能还不够满意，不够使用，完全可以扩展它，自己写一个插件来强化他。</p>\n<p>经过我的测试，功能绝对强大，可以满足市面上绝大多数的需求。接下来就说一下如何使用这款插件。</p>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h2><p>在项目中直接通过 <code>npm</code> 或者 <code>yarn</code> 下载插件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用 npm 安装</span></span><br><span class=\"line\">npm install braft-editor --save</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用 yarn 安装</span></span><br><span class=\"line\">yarn add braft-editor</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h2><p>新建一个组件 <code>EditorDemo.js</code>，在里面写入下列代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EditorDemo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> BraftEditor <span class=\"keyword\">from</span> <span class=\"string\">&#x27;braft-editor&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;braft-editor/dist/index.css&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PageDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    editorState: BraftEditor.createEditorState(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;BraftEditor value=&#123;<span class=\"built_in\">this</span>.state.editorState&#125; onChange=&#123;<span class=\"built_in\">this</span>.handleChange&#125;/&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange = <span class=\"function\">(<span class=\"params\">editorState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(&#123; editorState &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后引入到 <code>index.js</code> 中去。</p>\n<h2 id=\"3-运行\"><a href=\"#3-运行\" class=\"headerlink\" title=\"3.运行\"></a>3.运行</h2><p>写完组件之后，<code>npm start</code> 运行看看效果</p>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143022.png\"></p>\n<p>相当不错，页面很简洁，如果觉得样式不喜欢，完全可以自己重新定制风格，非常方便。</p>\n<h2 id=\"4-文档\"><a href=\"#4-文档\" class=\"headerlink\" title=\"4.文档\"></a>4.文档</h2><p>如果想使用更多功能、方法，进入 <a href=\"https://www.yuque.com/braft-editor/be/gz44tn\">Braft Editor 官方文档</a>吧，还有更多关于它的讲解！</p>\n<p>属性、方法、示例，一应俱全。</p>\n","site":{"data":{}},"length":1112,"excerpt":"<p>最近发了很多关于 React 的文章，记录遇到的新技术点，以及在写代码过程中遇到的问题，希望可以帮助到和我遇到同样问题的同学。</p>\n<p>今天分享的是一款基于 React 的富文本编辑器－－Braft Editor。</p>","more":"<blockquote>\n<p>Braft Editor 官网：<a href=\"https://braft.margox.cn/\">https://braft.margox.cn</a><br>Github 仓库地址：<a href=\"https://github.com/margox/braft-editor\">https://github.com/margox/braft-editor</a></p>\n</blockquote>\n<p>这款插件非常方便，只需要下载然后引入即可直接使用，页面整体风格清新，符合绝大多数人的审美观，支持图片，音视频的插入。</p>\n<p>按照官方的说法，假如你对它的功能还不够满意，不够使用，完全可以扩展它，自己写一个插件来强化他。</p>\n<p>经过我的测试，功能绝对强大，可以满足市面上绝大多数的需求。接下来就说一下如何使用这款插件。</p>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h2><p>在项目中直接通过 <code>npm</code> 或者 <code>yarn</code> 下载插件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用 npm 安装</span></span><br><span class=\"line\">npm install braft-editor --save</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用 yarn 安装</span></span><br><span class=\"line\">yarn add braft-editor</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h2><p>新建一个组件 <code>EditorDemo.js</code>，在里面写入下列代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// EditorDemo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> BraftEditor <span class=\"keyword\">from</span> <span class=\"string\">&#x27;braft-editor&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;braft-editor/dist/index.css&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PageDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    editorState: BraftEditor.createEditorState(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render () &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;BraftEditor value=&#123;<span class=\"built_in\">this</span>.state.editorState&#125; onChange=&#123;<span class=\"built_in\">this</span>.handleChange&#125;/&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleChange = <span class=\"function\">(<span class=\"params\">editorState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(&#123; editorState &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后引入到 <code>index.js</code> 中去。</p>\n<h2 id=\"3-运行\"><a href=\"#3-运行\" class=\"headerlink\" title=\"3.运行\"></a>3.运行</h2><p>写完组件之后，<code>npm start</code> 运行看看效果</p>\n<p><img src=\"https://shuxhan-imgbed.oss-cn-hangzhou.aliyuncs.com/img/20210108143022.png\"></p>\n<p>相当不错，页面很简洁，如果觉得样式不喜欢，完全可以自己重新定制风格，非常方便。</p>\n<h2 id=\"4-文档\"><a href=\"#4-文档\" class=\"headerlink\" title=\"4.文档\"></a>4.文档</h2><p>如果想使用更多功能、方法，进入 <a href=\"https://www.yuque.com/braft-editor/be/gz44tn\">Braft Editor 官方文档</a>吧，还有更多关于它的讲解！</p>\n<p>属性、方法、示例，一应俱全。</p>"},{"title":"－－－ 使用 simple99 前必看！！！－－－","date":"2021-01-13T16:00:00.000Z","top":9,"_content":"\n>公告：作者博客已迁移 **https://www.shuxhan.com** ，使用 typecho 进行博客写作，欢迎阅读，本站点仅做展示使用。**本站点评论系统关闭，主题仍然有评论系统，不用担心**，如有任何疑问，留言询问本主题相关，也请移至 [https://www.shuxhan.com/2021/01/14/hexo-typecho.html](https://www.shuxhan.com/2021/01/14/hexo-typecho.html) 文章下，或者给作者发一封邮件。\n\n2020.01.22，[shuxhan.com](https://www.shuxhan.com) 域名已经备案完成，欢迎访问。\n\n---\n\n2020.01.14，我将博客从 hexo 迁移到了 typecho , 因为服务器在国内，所以域名 [shuxhan.com](https://www.shuxhan.com) 需要备案，刚提交了申请。\n\n<green>但是 simple99 主题依旧会保持维护，有什么问题依旧可以询问。</green>\n\n正好之前我购买了一个域名 simple99.cn ，本来打算作为主题的文章说明网站使用，但中间有事情耽搁了，一直没有做出来，因此我将本站博客的域名改为了 **https://simple99.cn** ，作为展示用，在未来一段时间，我会逐渐将博客内容迁移到新的网站。\n\n但是因为更换了域名，因此这个站点的访客量不再保存，这也是没有办法的事情。\n\n我之所以将博客迁到 typecho ，主要是有以下几方面的考虑：\n\n1. 性能，使用 hexo 将博客托管在 github 上面，虽然可以通过 vercel 进行加速服务，但是依旧处于不稳定的状态，为了解决这个问题，我在阿里云续费了服务器。将通过服务器搭建我的个人博客。\n\n2. 静态博客的弊端很大，比如无法对博客进行动态操作，评论系统等也都是通过第三方程序，虽然方便，但是谁知道未来是什么情况呢？为了不必要的隐患，还是放在服务器数据库比较稳妥，同时，我将博客备份到了 github 仓库，以备不时之需。\n\n3. 写博客的时候如果不在同一台电脑是比较麻烦的，虽然可以通过别的方式进行同步，但是没有必要。这样我就可以在公司电脑和自用电脑之间切换了。\n\n虽然更换博客系统了，但我会一直保持对 [simple99](https://github.com/shuxhan/hexo-theme-simple99) 的维护更新。毕竟这也算是我的第一个开源项目，有一些特殊的感情。\n\n还有友链，我将会一一通知各位博主进行更换。","source":"_posts/20210114-hexo-typecho.md","raw":"---\ntitle: －－－ 使用 simple99 前必看！！！－－－\ndate: 2021-01-14  \ntop: 9\n---\n\n>公告：作者博客已迁移 **https://www.shuxhan.com** ，使用 typecho 进行博客写作，欢迎阅读，本站点仅做展示使用。**本站点评论系统关闭，主题仍然有评论系统，不用担心**，如有任何疑问，留言询问本主题相关，也请移至 [https://www.shuxhan.com/2021/01/14/hexo-typecho.html](https://www.shuxhan.com/2021/01/14/hexo-typecho.html) 文章下，或者给作者发一封邮件。\n\n2020.01.22，[shuxhan.com](https://www.shuxhan.com) 域名已经备案完成，欢迎访问。\n\n---\n\n2020.01.14，我将博客从 hexo 迁移到了 typecho , 因为服务器在国内，所以域名 [shuxhan.com](https://www.shuxhan.com) 需要备案，刚提交了申请。\n\n<green>但是 simple99 主题依旧会保持维护，有什么问题依旧可以询问。</green>\n\n正好之前我购买了一个域名 simple99.cn ，本来打算作为主题的文章说明网站使用，但中间有事情耽搁了，一直没有做出来，因此我将本站博客的域名改为了 **https://simple99.cn** ，作为展示用，在未来一段时间，我会逐渐将博客内容迁移到新的网站。\n\n但是因为更换了域名，因此这个站点的访客量不再保存，这也是没有办法的事情。\n\n我之所以将博客迁到 typecho ，主要是有以下几方面的考虑：\n\n1. 性能，使用 hexo 将博客托管在 github 上面，虽然可以通过 vercel 进行加速服务，但是依旧处于不稳定的状态，为了解决这个问题，我在阿里云续费了服务器。将通过服务器搭建我的个人博客。\n\n2. 静态博客的弊端很大，比如无法对博客进行动态操作，评论系统等也都是通过第三方程序，虽然方便，但是谁知道未来是什么情况呢？为了不必要的隐患，还是放在服务器数据库比较稳妥，同时，我将博客备份到了 github 仓库，以备不时之需。\n\n3. 写博客的时候如果不在同一台电脑是比较麻烦的，虽然可以通过别的方式进行同步，但是没有必要。这样我就可以在公司电脑和自用电脑之间切换了。\n\n虽然更换博客系统了，但我会一直保持对 [simple99](https://github.com/shuxhan/hexo-theme-simple99) 的维护更新。毕竟这也算是我的第一个开源项目，有一些特殊的感情。\n\n还有友链，我将会一一通知各位博主进行更换。","slug":"20210114-hexo-typecho","published":1,"updated":"2021-01-21T12:00:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckk6t0gyt000is6f07lgzg6sv","content":"<blockquote>\n<p>公告：作者博客已迁移 <strong><a href=\"https://www.shuxhan.com/\">https://www.shuxhan.com</a></strong> ，使用 typecho 进行博客写作，欢迎阅读，本站点仅做展示使用。<strong>本站点评论系统关闭，主题仍然有评论系统，不用担心</strong>，如有任何疑问，留言询问本主题相关，也请移至 <a href=\"https://www.shuxhan.com/2021/01/14/hexo-typecho.html\">https://www.shuxhan.com/2021/01/14/hexo-typecho.html</a> 文章下，或者给作者发一封邮件。</p>\n</blockquote>\n<p>2020.01.22，<a href=\"https://www.shuxhan.com/\">shuxhan.com</a> 域名已经备案完成，欢迎访问。</p>\n<hr>\n<p>2020.01.14，我将博客从 hexo 迁移到了 typecho , 因为服务器在国内，所以域名 <a href=\"https://www.shuxhan.com/\">shuxhan.com</a> 需要备案，刚提交了申请。</p>\n<p><green>但是 simple99 主题依旧会保持维护，有什么问题依旧可以询问。</green></p>\n<p>正好之前我购买了一个域名 simple99.cn ，本来打算作为主题的文章说明网站使用，但中间有事情耽搁了，一直没有做出来，因此我将本站博客的域名改为了 <strong><a href=\"https://simple99.cn/\">https://simple99.cn</a></strong> ，作为展示用，在未来一段时间，我会逐渐将博客内容迁移到新的网站。</p>\n<p>但是因为更换了域名，因此这个站点的访客量不再保存，这也是没有办法的事情。</p>\n<p>我之所以将博客迁到 typecho ，主要是有以下几方面的考虑：</p>\n<ol>\n<li><p>性能，使用 hexo 将博客托管在 github 上面，虽然可以通过 vercel 进行加速服务，但是依旧处于不稳定的状态，为了解决这个问题，我在阿里云续费了服务器。将通过服务器搭建我的个人博客。</p>\n</li>\n<li><p>静态博客的弊端很大，比如无法对博客进行动态操作，评论系统等也都是通过第三方程序，虽然方便，但是谁知道未来是什么情况呢？为了不必要的隐患，还是放在服务器数据库比较稳妥，同时，我将博客备份到了 github 仓库，以备不时之需。</p>\n</li>\n<li><p>写博客的时候如果不在同一台电脑是比较麻烦的，虽然可以通过别的方式进行同步，但是没有必要。这样我就可以在公司电脑和自用电脑之间切换了。</p>\n</li>\n</ol>\n<p>虽然更换博客系统了，但我会一直保持对 <a href=\"https://github.com/shuxhan/hexo-theme-simple99\">simple99</a> 的维护更新。毕竟这也算是我的第一个开源项目，有一些特殊的感情。</p>\n<p>还有友链，我将会一一通知各位博主进行更换。</p>\n","site":{"data":{}},"length":851,"excerpt":"","more":"<blockquote>\n<p>公告：作者博客已迁移 <strong><a href=\"https://www.shuxhan.com/\">https://www.shuxhan.com</a></strong> ，使用 typecho 进行博客写作，欢迎阅读，本站点仅做展示使用。<strong>本站点评论系统关闭，主题仍然有评论系统，不用担心</strong>，如有任何疑问，留言询问本主题相关，也请移至 <a href=\"https://www.shuxhan.com/2021/01/14/hexo-typecho.html\">https://www.shuxhan.com/2021/01/14/hexo-typecho.html</a> 文章下，或者给作者发一封邮件。</p>\n</blockquote>\n<p>2020.01.22，<a href=\"https://www.shuxhan.com/\">shuxhan.com</a> 域名已经备案完成，欢迎访问。</p>\n<hr>\n<p>2020.01.14，我将博客从 hexo 迁移到了 typecho , 因为服务器在国内，所以域名 <a href=\"https://www.shuxhan.com/\">shuxhan.com</a> 需要备案，刚提交了申请。</p>\n<p><green>但是 simple99 主题依旧会保持维护，有什么问题依旧可以询问。</green></p>\n<p>正好之前我购买了一个域名 simple99.cn ，本来打算作为主题的文章说明网站使用，但中间有事情耽搁了，一直没有做出来，因此我将本站博客的域名改为了 <strong><a href=\"https://simple99.cn/\">https://simple99.cn</a></strong> ，作为展示用，在未来一段时间，我会逐渐将博客内容迁移到新的网站。</p>\n<p>但是因为更换了域名，因此这个站点的访客量不再保存，这也是没有办法的事情。</p>\n<p>我之所以将博客迁到 typecho ，主要是有以下几方面的考虑：</p>\n<ol>\n<li><p>性能，使用 hexo 将博客托管在 github 上面，虽然可以通过 vercel 进行加速服务，但是依旧处于不稳定的状态，为了解决这个问题，我在阿里云续费了服务器。将通过服务器搭建我的个人博客。</p>\n</li>\n<li><p>静态博客的弊端很大，比如无法对博客进行动态操作，评论系统等也都是通过第三方程序，虽然方便，但是谁知道未来是什么情况呢？为了不必要的隐患，还是放在服务器数据库比较稳妥，同时，我将博客备份到了 github 仓库，以备不时之需。</p>\n</li>\n<li><p>写博客的时候如果不在同一台电脑是比较麻烦的，虽然可以通过别的方式进行同步，但是没有必要。这样我就可以在公司电脑和自用电脑之间切换了。</p>\n</li>\n</ol>\n<p>虽然更换博客系统了，但我会一直保持对 <a href=\"https://github.com/shuxhan/hexo-theme-simple99\">simple99</a> 的维护更新。毕竟这也算是我的第一个开源项目，有一些特殊的感情。</p>\n<p>还有友链，我将会一一通知各位博主进行更换。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckk6t0gyj0009s6f0eakoaw4j","category_id":"ckk6t0gye0004s6f0g0lccj5u","_id":"ckk6t0gyu000js6f0ed386yjx"},{"post_id":"ckk6t0gy80001s6f0huuyb7rl","category_id":"ckk6t0gye0004s6f0g0lccj5u","_id":"ckk6t0gyx000ms6f0gmw05wnt"},{"post_id":"ckk6t0gyc0003s6f05uox3v0a","category_id":"ckk6t0gym000cs6f06acqh55n","_id":"ckk6t0gyy000os6f0ck0hdilc"},{"post_id":"ckk6t0gyh0007s6f06s8o0b46","category_id":"ckk6t0gym000cs6f06acqh55n","_id":"ckk6t0gyz000qs6f0fyb1ekg6"},{"post_id":"ckk6t0gyl000bs6f021aj5apg","category_id":"ckk6t0gyx000ns6f04hk68mdi","_id":"ckk6t0gz0000ts6f02jh0bnis"},{"post_id":"ckk6t0gyp000fs6f0c1qgfwxt","category_id":"ckk6t0gyx000ns6f04hk68mdi","_id":"ckk6t0gz0000vs6f033twgkid"}],"PostTag":[{"post_id":"ckk6t0gyj0009s6f0eakoaw4j","tag_id":"ckk6t0gyg0005s6f0775he05y","_id":"ckk6t0gyn000ds6f0dz1cflhq"},{"post_id":"ckk6t0gy80001s6f0huuyb7rl","tag_id":"ckk6t0gyg0005s6f0775he05y","_id":"ckk6t0gyr000gs6f0aowzf4wy"},{"post_id":"ckk6t0gyp000fs6f0c1qgfwxt","tag_id":"ckk6t0gyw000ls6f00i5n9a7w","_id":"ckk6t0gz0000ss6f0f1p25eoz"},{"post_id":"ckk6t0gyp000fs6f0c1qgfwxt","tag_id":"ckk6t0gyy000ps6f0ak4acyxn","_id":"ckk6t0gz0000us6f06hwieom6"}],"Tag":[{"name":"建站手册及问题","_id":"ckk6t0gyg0005s6f0775he05y"},{"name":"react 杂谈","_id":"ckk6t0gyw000ls6f00i5n9a7w"},{"name":"组件库","_id":"ckk6t0gyy000ps6f0ak4acyxn"}]}}